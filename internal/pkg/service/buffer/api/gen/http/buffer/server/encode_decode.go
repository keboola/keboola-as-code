// Code generated by goa v3.11.1, DO NOT EDIT.
//
// buffer HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/keboola/keboola-as-code/api/buffer --output
// ./internal/pkg/service/buffer/api

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strconv"
	"strings"
	"unicode/utf8"

	buffer "github.com/keboola/keboola-as-code/internal/pkg/service/buffer/api/gen/buffer"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeAPIVersionIndexResponse returns an encoder for responses returned by
// the buffer ApiVersionIndex endpoint.
func EncodeAPIVersionIndexResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*buffer.ServiceDetail)
		enc := encoder(ctx, w)
		body := NewAPIVersionIndexResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeHealthCheckResponse returns an encoder for responses returned by the
// buffer HealthCheck endpoint.
func EncodeHealthCheckResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(string)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "text/plain")
		enc := encoder(ctx, w)
		body := res
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeCreateReceiverResponse returns an encoder for responses returned by
// the buffer CreateReceiver endpoint.
func EncodeCreateReceiverResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*buffer.Task)
		enc := encoder(ctx, w)
		body := NewCreateReceiverResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeCreateReceiverRequest returns a decoder for requests sent to the
// buffer CreateReceiver endpoint.
func DecodeCreateReceiverRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body CreateReceiverRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateReceiverRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			storageAPIToken string
		)
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateReceiverPayload(&body, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeCreateReceiverError returns an encoder for errors returned by the
// CreateReceiver buffer endpoint.
func EncodeCreateReceiverError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "buffer.receiverAlreadyExists":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusConflict
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateReceiverBufferReceiverAlreadyExistsResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "buffer.resourceLimitReached":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusUnprocessableEntity
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateReceiverBufferResourceLimitReachedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnprocessableEntity)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateReceiverResponse returns an encoder for responses returned by
// the buffer UpdateReceiver endpoint.
func EncodeUpdateReceiverResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*buffer.Receiver)
		enc := encoder(ctx, w)
		body := NewUpdateReceiverResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateReceiverRequest returns a decoder for requests sent to the
// buffer UpdateReceiver endpoint.
func DecodeUpdateReceiverRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body UpdateReceiverRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateReceiverRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			receiverID      string
			storageAPIToken string

			params = mux.Vars(r)
		)
		receiverID = params["receiverId"]
		if utf8.RuneCountInString(receiverID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 1, true))
		}
		if utf8.RuneCountInString(receiverID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateReceiverPayload(&body, receiverID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpdateReceiverError returns an encoder for errors returned by the
// UpdateReceiver buffer endpoint.
func EncodeUpdateReceiverError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "buffer.receiverNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateReceiverBufferReceiverNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListReceiversResponse returns an encoder for responses returned by the
// buffer ListReceivers endpoint.
func EncodeListReceiversResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*buffer.ReceiversList)
		enc := encoder(ctx, w)
		body := NewListReceiversResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListReceiversRequest returns a decoder for requests sent to the buffer
// ListReceivers endpoint.
func DecodeListReceiversRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			storageAPIToken string
			err             error
		)
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewListReceiversPayload(storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetReceiverResponse returns an encoder for responses returned by the
// buffer GetReceiver endpoint.
func EncodeGetReceiverResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*buffer.Receiver)
		enc := encoder(ctx, w)
		body := NewGetReceiverResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetReceiverRequest returns a decoder for requests sent to the buffer
// GetReceiver endpoint.
func DecodeGetReceiverRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			receiverID      string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		receiverID = params["receiverId"]
		if utf8.RuneCountInString(receiverID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 1, true))
		}
		if utf8.RuneCountInString(receiverID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetReceiverPayload(receiverID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetReceiverError returns an encoder for errors returned by the
// GetReceiver buffer endpoint.
func EncodeGetReceiverError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "buffer.receiverNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetReceiverBufferReceiverNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteReceiverResponse returns an encoder for responses returned by
// the buffer DeleteReceiver endpoint.
func EncodeDeleteReceiverResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		w.WriteHeader(http.StatusOK)
		return nil
	}
}

// DecodeDeleteReceiverRequest returns a decoder for requests sent to the
// buffer DeleteReceiver endpoint.
func DecodeDeleteReceiverRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			receiverID      string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		receiverID = params["receiverId"]
		if utf8.RuneCountInString(receiverID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 1, true))
		}
		if utf8.RuneCountInString(receiverID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteReceiverPayload(receiverID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeDeleteReceiverError returns an encoder for errors returned by the
// DeleteReceiver buffer endpoint.
func EncodeDeleteReceiverError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "buffer.receiverNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteReceiverBufferReceiverNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeRefreshReceiverTokensResponse returns an encoder for responses
// returned by the buffer RefreshReceiverTokens endpoint.
func EncodeRefreshReceiverTokensResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*buffer.Receiver)
		enc := encoder(ctx, w)
		body := NewRefreshReceiverTokensResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeRefreshReceiverTokensRequest returns a decoder for requests sent to
// the buffer RefreshReceiverTokens endpoint.
func DecodeRefreshReceiverTokensRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			receiverID      string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		receiverID = params["receiverId"]
		if utf8.RuneCountInString(receiverID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 1, true))
		}
		if utf8.RuneCountInString(receiverID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewRefreshReceiverTokensPayload(receiverID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeRefreshReceiverTokensError returns an encoder for errors returned by
// the RefreshReceiverTokens buffer endpoint.
func EncodeRefreshReceiverTokensError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "buffer.receiverNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRefreshReceiverTokensBufferReceiverNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateExportResponse returns an encoder for responses returned by the
// buffer CreateExport endpoint.
func EncodeCreateExportResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*buffer.Task)
		enc := encoder(ctx, w)
		body := NewCreateExportResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeCreateExportRequest returns a decoder for requests sent to the buffer
// CreateExport endpoint.
func DecodeCreateExportRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body CreateExportRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateExportRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			receiverID      string
			storageAPIToken string

			params = mux.Vars(r)
		)
		receiverID = params["receiverId"]
		if utf8.RuneCountInString(receiverID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 1, true))
		}
		if utf8.RuneCountInString(receiverID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateExportPayload(&body, receiverID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeCreateExportError returns an encoder for errors returned by the
// CreateExport buffer endpoint.
func EncodeCreateExportError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "buffer.receiverNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateExportBufferReceiverNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "buffer.exportAlreadyExists":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusConflict
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateExportBufferExportAlreadyExistsResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "buffer.resourceLimitReached":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusUnprocessableEntity
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateExportBufferResourceLimitReachedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnprocessableEntity)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetExportResponse returns an encoder for responses returned by the
// buffer GetExport endpoint.
func EncodeGetExportResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*buffer.Export)
		enc := encoder(ctx, w)
		body := NewGetExportResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetExportRequest returns a decoder for requests sent to the buffer
// GetExport endpoint.
func DecodeGetExportRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			receiverID      string
			exportID        string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		receiverID = params["receiverId"]
		if utf8.RuneCountInString(receiverID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 1, true))
		}
		if utf8.RuneCountInString(receiverID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 48, false))
		}
		exportID = params["exportId"]
		if utf8.RuneCountInString(exportID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("exportID", exportID, utf8.RuneCountInString(exportID), 1, true))
		}
		if utf8.RuneCountInString(exportID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("exportID", exportID, utf8.RuneCountInString(exportID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetExportPayload(receiverID, exportID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetExportError returns an encoder for errors returned by the GetExport
// buffer endpoint.
func EncodeGetExportError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "buffer.receiverNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetExportBufferReceiverNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "buffer.exportNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetExportBufferExportNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListExportsResponse returns an encoder for responses returned by the
// buffer ListExports endpoint.
func EncodeListExportsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*buffer.ExportsList)
		enc := encoder(ctx, w)
		body := NewListExportsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListExportsRequest returns a decoder for requests sent to the buffer
// ListExports endpoint.
func DecodeListExportsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			receiverID      string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		receiverID = params["receiverId"]
		if utf8.RuneCountInString(receiverID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 1, true))
		}
		if utf8.RuneCountInString(receiverID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewListExportsPayload(receiverID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeListExportsError returns an encoder for errors returned by the
// ListExports buffer endpoint.
func EncodeListExportsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "buffer.receiverNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListExportsBufferReceiverNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateExportResponse returns an encoder for responses returned by the
// buffer UpdateExport endpoint.
func EncodeUpdateExportResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*buffer.Task)
		enc := encoder(ctx, w)
		body := NewUpdateExportResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateExportRequest returns a decoder for requests sent to the buffer
// UpdateExport endpoint.
func DecodeUpdateExportRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body UpdateExportRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateExportRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			receiverID      string
			exportID        string
			storageAPIToken string

			params = mux.Vars(r)
		)
		receiverID = params["receiverId"]
		if utf8.RuneCountInString(receiverID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 1, true))
		}
		if utf8.RuneCountInString(receiverID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 48, false))
		}
		exportID = params["exportId"]
		if utf8.RuneCountInString(exportID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("exportID", exportID, utf8.RuneCountInString(exportID), 1, true))
		}
		if utf8.RuneCountInString(exportID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("exportID", exportID, utf8.RuneCountInString(exportID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateExportPayload(&body, receiverID, exportID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpdateExportError returns an encoder for errors returned by the
// UpdateExport buffer endpoint.
func EncodeUpdateExportError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "buffer.receiverNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateExportBufferReceiverNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "buffer.exportNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateExportBufferExportNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteExportResponse returns an encoder for responses returned by the
// buffer DeleteExport endpoint.
func EncodeDeleteExportResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		w.WriteHeader(http.StatusOK)
		return nil
	}
}

// DecodeDeleteExportRequest returns a decoder for requests sent to the buffer
// DeleteExport endpoint.
func DecodeDeleteExportRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			receiverID      string
			exportID        string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		receiverID = params["receiverId"]
		if utf8.RuneCountInString(receiverID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 1, true))
		}
		if utf8.RuneCountInString(receiverID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 48, false))
		}
		exportID = params["exportId"]
		if utf8.RuneCountInString(exportID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("exportID", exportID, utf8.RuneCountInString(exportID), 1, true))
		}
		if utf8.RuneCountInString(exportID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("exportID", exportID, utf8.RuneCountInString(exportID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteExportPayload(receiverID, exportID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeDeleteExportError returns an encoder for errors returned by the
// DeleteExport buffer endpoint.
func EncodeDeleteExportError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "buffer.receiverNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteExportBufferReceiverNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "buffer.exportNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteExportBufferExportNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeImportResponse returns an encoder for responses returned by the buffer
// Import endpoint.
func EncodeImportResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		w.WriteHeader(http.StatusOK)
		return nil
	}
}

// DecodeImportRequest returns a decoder for requests sent to the buffer Import
// endpoint.
func DecodeImportRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			projectID   int
			receiverID  string
			secret      string
			contentType string
			err         error

			params = mux.Vars(r)
		)
		{
			projectIDRaw := params["projectId"]
			v, err2 := strconv.ParseInt(projectIDRaw, 10, strconv.IntSize)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("projectID", projectIDRaw, "integer"))
			}
			projectID = int(v)
		}
		receiverID = params["receiverId"]
		if utf8.RuneCountInString(receiverID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 1, true))
		}
		if utf8.RuneCountInString(receiverID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("receiverID", receiverID, utf8.RuneCountInString(receiverID), 48, false))
		}
		secret = params["secret"]
		if utf8.RuneCountInString(secret) < 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("secret", secret, utf8.RuneCountInString(secret), 48, true))
		}
		if utf8.RuneCountInString(secret) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("secret", secret, utf8.RuneCountInString(secret), 48, false))
		}
		contentType = r.Header.Get("Content-Type")
		if contentType == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Content-Type", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewImportPayload(projectID, receiverID, secret, contentType)

		return payload, nil
	}
}

// EncodeImportError returns an encoder for errors returned by the Import
// buffer endpoint.
func EncodeImportError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "buffer.receiverNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewImportBufferReceiverNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "buffer.payloadTooLarge":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusRequestEntityTooLarge
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewImportBufferPayloadTooLargeResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusRequestEntityTooLarge)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetTaskResponse returns an encoder for responses returned by the
// buffer GetTask endpoint.
func EncodeGetTaskResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*buffer.Task)
		enc := encoder(ctx, w)
		body := NewGetTaskResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetTaskRequest returns a decoder for requests sent to the buffer
// GetTask endpoint.
func DecodeGetTaskRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			taskID          string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		taskID = params["taskId"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetTaskPayload(taskID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetTaskError returns an encoder for errors returned by the GetTask
// buffer endpoint.
func EncodeGetTaskError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "buffer.taskNotFound":
			var res *buffer.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body interface{}
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetTaskBufferTaskNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// unmarshalCreateExportDataRequestBodyToBufferCreateExportData builds a value
// of type *buffer.CreateExportData from a value of type
// *CreateExportDataRequestBody.
func unmarshalCreateExportDataRequestBodyToBufferCreateExportData(v *CreateExportDataRequestBody) *buffer.CreateExportData {
	if v == nil {
		return nil
	}
	res := &buffer.CreateExportData{
		Name: *v.Name,
	}
	if v.ID != nil {
		id := buffer.ExportID(*v.ID)
		res.ID = &id
	}
	res.Mapping = unmarshalMappingRequestBodyToBufferMapping(v.Mapping)
	if v.Conditions != nil {
		res.Conditions = unmarshalConditionsRequestBodyToBufferConditions(v.Conditions)
	}

	return res
}

// unmarshalMappingRequestBodyToBufferMapping builds a value of type
// *buffer.Mapping from a value of type *MappingRequestBody.
func unmarshalMappingRequestBodyToBufferMapping(v *MappingRequestBody) *buffer.Mapping {
	res := &buffer.Mapping{
		TableID:     *v.TableID,
		Incremental: v.Incremental,
	}
	res.Columns = make([]*buffer.Column, len(v.Columns))
	for i, val := range v.Columns {
		res.Columns[i] = unmarshalColumnRequestBodyToBufferColumn(val)
	}

	return res
}

// unmarshalColumnRequestBodyToBufferColumn builds a value of type
// *buffer.Column from a value of type *ColumnRequestBody.
func unmarshalColumnRequestBodyToBufferColumn(v *ColumnRequestBody) *buffer.Column {
	res := &buffer.Column{
		Type: *v.Type,
		Name: *v.Name,
	}
	if v.PrimaryKey != nil {
		res.PrimaryKey = *v.PrimaryKey
	}
	if v.PrimaryKey == nil {
		res.PrimaryKey = false
	}
	if v.Template != nil {
		res.Template = unmarshalTemplateRequestBodyToBufferTemplate(v.Template)
	}

	return res
}

// unmarshalTemplateRequestBodyToBufferTemplate builds a value of type
// *buffer.Template from a value of type *TemplateRequestBody.
func unmarshalTemplateRequestBodyToBufferTemplate(v *TemplateRequestBody) *buffer.Template {
	if v == nil {
		return nil
	}
	res := &buffer.Template{
		Language: *v.Language,
		Content:  *v.Content,
	}

	return res
}

// unmarshalConditionsRequestBodyToBufferConditions builds a value of type
// *buffer.Conditions from a value of type *ConditionsRequestBody.
func unmarshalConditionsRequestBodyToBufferConditions(v *ConditionsRequestBody) *buffer.Conditions {
	if v == nil {
		return nil
	}
	res := &buffer.Conditions{}
	if v.Count != nil {
		res.Count = *v.Count
	}
	if v.Size != nil {
		res.Size = *v.Size
	}
	if v.Time != nil {
		res.Time = *v.Time
	}
	if v.Count == nil {
		res.Count = 10000
	}
	if v.Size == nil {
		res.Size = "5MB"
	}
	if v.Time == nil {
		res.Time = "5m0s"
	}

	return res
}

// marshalBufferTaskOutputsToTaskOutputsResponseBody builds a value of type
// *TaskOutputsResponseBody from a value of type *buffer.TaskOutputs.
func marshalBufferTaskOutputsToTaskOutputsResponseBody(v *buffer.TaskOutputs) *TaskOutputsResponseBody {
	if v == nil {
		return nil
	}
	res := &TaskOutputsResponseBody{
		ExportID:   v.ExportID,
		ReceiverID: v.ReceiverID,
	}

	return res
}

// marshalBufferExportToExportResponseBody builds a value of type
// *ExportResponseBody from a value of type *buffer.Export.
func marshalBufferExportToExportResponseBody(v *buffer.Export) *ExportResponseBody {
	res := &ExportResponseBody{
		ID:         string(v.ID),
		ReceiverID: string(v.ReceiverID),
		Name:       v.Name,
	}
	if v.Mapping != nil {
		res.Mapping = marshalBufferMappingToMappingResponseBody(v.Mapping)
	}
	if v.Conditions != nil {
		res.Conditions = marshalBufferConditionsToConditionsResponseBody(v.Conditions)
	}

	return res
}

// marshalBufferMappingToMappingResponseBody builds a value of type
// *MappingResponseBody from a value of type *buffer.Mapping.
func marshalBufferMappingToMappingResponseBody(v *buffer.Mapping) *MappingResponseBody {
	res := &MappingResponseBody{
		TableID:     v.TableID,
		Incremental: v.Incremental,
	}
	if v.Columns != nil {
		res.Columns = make([]*ColumnResponseBody, len(v.Columns))
		for i, val := range v.Columns {
			res.Columns[i] = marshalBufferColumnToColumnResponseBody(val)
		}
	}

	return res
}

// marshalBufferColumnToColumnResponseBody builds a value of type
// *ColumnResponseBody from a value of type *buffer.Column.
func marshalBufferColumnToColumnResponseBody(v *buffer.Column) *ColumnResponseBody {
	res := &ColumnResponseBody{
		PrimaryKey: v.PrimaryKey,
		Type:       v.Type,
		Name:       v.Name,
	}
	{
		var zero bool
		if res.PrimaryKey == zero {
			res.PrimaryKey = false
		}
	}
	if v.Template != nil {
		res.Template = marshalBufferTemplateToTemplateResponseBody(v.Template)
	}

	return res
}

// marshalBufferTemplateToTemplateResponseBody builds a value of type
// *TemplateResponseBody from a value of type *buffer.Template.
func marshalBufferTemplateToTemplateResponseBody(v *buffer.Template) *TemplateResponseBody {
	if v == nil {
		return nil
	}
	res := &TemplateResponseBody{
		Language: v.Language,
		Content:  v.Content,
	}

	return res
}

// marshalBufferConditionsToConditionsResponseBody builds a value of type
// *ConditionsResponseBody from a value of type *buffer.Conditions.
func marshalBufferConditionsToConditionsResponseBody(v *buffer.Conditions) *ConditionsResponseBody {
	res := &ConditionsResponseBody{
		Count: v.Count,
		Size:  v.Size,
		Time:  v.Time,
	}
	{
		var zero int
		if res.Count == zero {
			res.Count = 10000
		}
	}
	{
		var zero string
		if res.Size == zero {
			res.Size = "5MB"
		}
	}
	{
		var zero string
		if res.Time == zero {
			res.Time = "5m0s"
		}
	}

	return res
}

// marshalBufferReceiverToReceiverResponseBody builds a value of type
// *ReceiverResponseBody from a value of type *buffer.Receiver.
func marshalBufferReceiverToReceiverResponseBody(v *buffer.Receiver) *ReceiverResponseBody {
	res := &ReceiverResponseBody{
		ID:          string(v.ID),
		URL:         v.URL,
		Name:        v.Name,
		Description: v.Description,
	}
	if v.Exports != nil {
		res.Exports = make([]*ExportResponseBody, len(v.Exports))
		for i, val := range v.Exports {
			res.Exports[i] = marshalBufferExportToExportResponseBody(val)
		}
	}

	return res
}
