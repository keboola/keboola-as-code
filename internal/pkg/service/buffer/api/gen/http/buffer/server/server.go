// Code generated by goa v3.11.3, DO NOT EDIT.
//
// buffer HTTP server
//
// Command:
// $ goa gen github.com/keboola/keboola-as-code/api/buffer --output
// ./internal/pkg/service/buffer/api

package server

import (
	"context"
	"net/http"

	buffer "github.com/keboola/keboola-as-code/internal/pkg/service/buffer/api/gen/buffer"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
	"goa.design/plugins/v3/cors"
)

// Server lists the buffer service endpoint HTTP handlers.
type Server struct {
	Mounts                []*MountPoint
	APIRootIndex          http.Handler
	APIVersionIndex       http.Handler
	HealthCheck           http.Handler
	CreateReceiver        http.Handler
	UpdateReceiver        http.Handler
	ListReceivers         http.Handler
	GetReceiver           http.Handler
	DeleteReceiver        http.Handler
	RefreshReceiverTokens http.Handler
	CreateExport          http.Handler
	GetExport             http.Handler
	ListExports           http.Handler
	UpdateExport          http.Handler
	DeleteExport          http.Handler
	Import                http.Handler
	GetTask               http.Handler
	CORS                  http.Handler
	OpenapiJSON           http.Handler
	OpenapiYaml           http.Handler
	Openapi3JSON          http.Handler
	Openapi3Yaml          http.Handler
	SwaggerUI             http.Handler
}

// MountPoint holds information about the mounted endpoints.
type MountPoint struct {
	// Method is the name of the service method served by the mounted HTTP handler.
	Method string
	// Verb is the HTTP method used to match requests to the mounted handler.
	Verb string
	// Pattern is the HTTP request path pattern used to match requests to the
	// mounted handler.
	Pattern string
}

// New instantiates HTTP handlers for all the buffer service endpoints using
// the provided encoder and decoder. The handlers are mounted on the given mux
// using the HTTP verb and path defined in the design. errhandler is called
// whenever a response fails to be encoded. formatter is used to format errors
// returned by the service methods prior to encoding. Both errhandler and
// formatter are optional and can be nil.
func New(
	e *buffer.Endpoints,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
	fileSystemOpenapiJSON http.FileSystem,
	fileSystemOpenapiYaml http.FileSystem,
	fileSystemOpenapi3JSON http.FileSystem,
	fileSystemOpenapi3Yaml http.FileSystem,
	fileSystemSwaggerUI http.FileSystem,
) *Server {
	if fileSystemOpenapiJSON == nil {
		fileSystemOpenapiJSON = http.Dir(".")
	}
	if fileSystemOpenapiYaml == nil {
		fileSystemOpenapiYaml = http.Dir(".")
	}
	if fileSystemOpenapi3JSON == nil {
		fileSystemOpenapi3JSON = http.Dir(".")
	}
	if fileSystemOpenapi3Yaml == nil {
		fileSystemOpenapi3Yaml = http.Dir(".")
	}
	if fileSystemSwaggerUI == nil {
		fileSystemSwaggerUI = http.Dir(".")
	}
	return &Server{
		Mounts: []*MountPoint{
			{"APIRootIndex", "GET", "/"},
			{"APIVersionIndex", "GET", "/v1"},
			{"HealthCheck", "GET", "/health-check"},
			{"CreateReceiver", "POST", "/v1/receivers"},
			{"UpdateReceiver", "PATCH", "/v1/receivers/{receiverId}"},
			{"ListReceivers", "GET", "/v1/receivers"},
			{"GetReceiver", "GET", "/v1/receivers/{receiverId}"},
			{"DeleteReceiver", "DELETE", "/v1/receivers/{receiverId}"},
			{"RefreshReceiverTokens", "POST", "/v1/receivers/{receiverId}/tokens/refresh"},
			{"CreateExport", "POST", "/v1/receivers/{receiverId}/exports"},
			{"GetExport", "GET", "/v1/receivers/{receiverId}/exports/{exportId}"},
			{"ListExports", "GET", "/v1/receivers/{receiverId}/exports"},
			{"UpdateExport", "PATCH", "/v1/receivers/{receiverId}/exports/{exportId}"},
			{"DeleteExport", "DELETE", "/v1/receivers/{receiverId}/exports/{exportId}"},
			{"Import", "POST", "/v1/import/{projectId}/{receiverId}/{secret}"},
			{"GetTask", "GET", "/v1/tasks/{*taskId}"},
			{"CORS", "OPTIONS", "/"},
			{"CORS", "OPTIONS", "/v1"},
			{"CORS", "OPTIONS", "/health-check"},
			{"CORS", "OPTIONS", "/v1/receivers"},
			{"CORS", "OPTIONS", "/v1/receivers/{receiverId}"},
			{"CORS", "OPTIONS", "/v1/receivers/{receiverId}/tokens/refresh"},
			{"CORS", "OPTIONS", "/v1/receivers/{receiverId}/exports"},
			{"CORS", "OPTIONS", "/v1/receivers/{receiverId}/exports/{exportId}"},
			{"CORS", "OPTIONS", "/v1/import/{projectId}/{receiverId}/{secret}"},
			{"CORS", "OPTIONS", "/v1/tasks/{*taskId}"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi.json"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi.yaml"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi3.json"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi3.yaml"},
			{"CORS", "OPTIONS", "/v1/documentation/{*path}"},
			{"openapi.json", "GET", "/v1/documentation/openapi.json"},
			{"openapi.yaml", "GET", "/v1/documentation/openapi.yaml"},
			{"openapi3.json", "GET", "/v1/documentation/openapi3.json"},
			{"openapi3.yaml", "GET", "/v1/documentation/openapi3.yaml"},
			{"swagger-ui", "GET", "/v1/documentation"},
		},
		APIRootIndex:          NewAPIRootIndexHandler(e.APIRootIndex, mux, decoder, encoder, errhandler, formatter),
		APIVersionIndex:       NewAPIVersionIndexHandler(e.APIVersionIndex, mux, decoder, encoder, errhandler, formatter),
		HealthCheck:           NewHealthCheckHandler(e.HealthCheck, mux, decoder, encoder, errhandler, formatter),
		CreateReceiver:        NewCreateReceiverHandler(e.CreateReceiver, mux, decoder, encoder, errhandler, formatter),
		UpdateReceiver:        NewUpdateReceiverHandler(e.UpdateReceiver, mux, decoder, encoder, errhandler, formatter),
		ListReceivers:         NewListReceiversHandler(e.ListReceivers, mux, decoder, encoder, errhandler, formatter),
		GetReceiver:           NewGetReceiverHandler(e.GetReceiver, mux, decoder, encoder, errhandler, formatter),
		DeleteReceiver:        NewDeleteReceiverHandler(e.DeleteReceiver, mux, decoder, encoder, errhandler, formatter),
		RefreshReceiverTokens: NewRefreshReceiverTokensHandler(e.RefreshReceiverTokens, mux, decoder, encoder, errhandler, formatter),
		CreateExport:          NewCreateExportHandler(e.CreateExport, mux, decoder, encoder, errhandler, formatter),
		GetExport:             NewGetExportHandler(e.GetExport, mux, decoder, encoder, errhandler, formatter),
		ListExports:           NewListExportsHandler(e.ListExports, mux, decoder, encoder, errhandler, formatter),
		UpdateExport:          NewUpdateExportHandler(e.UpdateExport, mux, decoder, encoder, errhandler, formatter),
		DeleteExport:          NewDeleteExportHandler(e.DeleteExport, mux, decoder, encoder, errhandler, formatter),
		Import:                NewImportHandler(e.Import, mux, decoder, encoder, errhandler, formatter),
		GetTask:               NewGetTaskHandler(e.GetTask, mux, decoder, encoder, errhandler, formatter),
		CORS:                  NewCORSHandler(),
		OpenapiJSON:           http.FileServer(fileSystemOpenapiJSON),
		OpenapiYaml:           http.FileServer(fileSystemOpenapiYaml),
		Openapi3JSON:          http.FileServer(fileSystemOpenapi3JSON),
		Openapi3Yaml:          http.FileServer(fileSystemOpenapi3Yaml),
		SwaggerUI:             http.FileServer(fileSystemSwaggerUI),
	}
}

// Service returns the name of the service served.
func (s *Server) Service() string { return "buffer" }

// Use wraps the server handlers with the given middleware.
func (s *Server) Use(m func(http.Handler) http.Handler) {
	s.APIRootIndex = m(s.APIRootIndex)
	s.APIVersionIndex = m(s.APIVersionIndex)
	s.HealthCheck = m(s.HealthCheck)
	s.CreateReceiver = m(s.CreateReceiver)
	s.UpdateReceiver = m(s.UpdateReceiver)
	s.ListReceivers = m(s.ListReceivers)
	s.GetReceiver = m(s.GetReceiver)
	s.DeleteReceiver = m(s.DeleteReceiver)
	s.RefreshReceiverTokens = m(s.RefreshReceiverTokens)
	s.CreateExport = m(s.CreateExport)
	s.GetExport = m(s.GetExport)
	s.ListExports = m(s.ListExports)
	s.UpdateExport = m(s.UpdateExport)
	s.DeleteExport = m(s.DeleteExport)
	s.Import = m(s.Import)
	s.GetTask = m(s.GetTask)
	s.CORS = m(s.CORS)
}

// MethodNames returns the methods served.
func (s *Server) MethodNames() []string { return buffer.MethodNames[:] }

// Mount configures the mux to serve the buffer endpoints.
func Mount(mux goahttp.Muxer, h *Server) {
	MountAPIRootIndexHandler(mux, h.APIRootIndex)
	MountAPIVersionIndexHandler(mux, h.APIVersionIndex)
	MountHealthCheckHandler(mux, h.HealthCheck)
	MountCreateReceiverHandler(mux, h.CreateReceiver)
	MountUpdateReceiverHandler(mux, h.UpdateReceiver)
	MountListReceiversHandler(mux, h.ListReceivers)
	MountGetReceiverHandler(mux, h.GetReceiver)
	MountDeleteReceiverHandler(mux, h.DeleteReceiver)
	MountRefreshReceiverTokensHandler(mux, h.RefreshReceiverTokens)
	MountCreateExportHandler(mux, h.CreateExport)
	MountGetExportHandler(mux, h.GetExport)
	MountListExportsHandler(mux, h.ListExports)
	MountUpdateExportHandler(mux, h.UpdateExport)
	MountDeleteExportHandler(mux, h.DeleteExport)
	MountImportHandler(mux, h.Import)
	MountGetTaskHandler(mux, h.GetTask)
	MountCORSHandler(mux, h.CORS)
	MountOpenapiJSON(mux, goahttp.Replace("", "/openapi.json", h.OpenapiJSON))
	MountOpenapiYaml(mux, goahttp.Replace("", "/openapi.yaml", h.OpenapiYaml))
	MountOpenapi3JSON(mux, goahttp.Replace("", "/openapi3.json", h.Openapi3JSON))
	MountOpenapi3Yaml(mux, goahttp.Replace("", "/openapi3.yaml", h.Openapi3Yaml))
	MountSwaggerUI(mux, goahttp.Replace("/v1/documentation", "/swagger-ui", h.SwaggerUI))
}

// Mount configures the mux to serve the buffer endpoints.
func (s *Server) Mount(mux goahttp.Muxer) {
	Mount(mux, s)
}

// MountAPIRootIndexHandler configures the mux to serve the "buffer" service
// "ApiRootIndex" endpoint.
func MountAPIRootIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/", f)
}

// NewAPIRootIndexHandler creates a HTTP handler which loads the HTTP request
// and calls the "buffer" service "ApiRootIndex" endpoint.
func NewAPIRootIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ApiRootIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		http.Redirect(w, r, "/v1", http.StatusMovedPermanently)
	})
}

// MountAPIVersionIndexHandler configures the mux to serve the "buffer" service
// "ApiVersionIndex" endpoint.
func MountAPIVersionIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1", f)
}

// NewAPIVersionIndexHandler creates a HTTP handler which loads the HTTP
// request and calls the "buffer" service "ApiVersionIndex" endpoint.
func NewAPIVersionIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		encodeResponse = EncodeAPIVersionIndexResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ApiVersionIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		var err error
		res, err := endpoint(ctx, nil)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountHealthCheckHandler configures the mux to serve the "buffer" service
// "HealthCheck" endpoint.
func MountHealthCheckHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/health-check", f)
}

// NewHealthCheckHandler creates a HTTP handler which loads the HTTP request
// and calls the "buffer" service "HealthCheck" endpoint.
func NewHealthCheckHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		encodeResponse = EncodeHealthCheckResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "HealthCheck")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		var err error
		res, err := endpoint(ctx, nil)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreateReceiverHandler configures the mux to serve the "buffer" service
// "CreateReceiver" endpoint.
func MountCreateReceiverHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/receivers", f)
}

// NewCreateReceiverHandler creates a HTTP handler which loads the HTTP request
// and calls the "buffer" service "CreateReceiver" endpoint.
func NewCreateReceiverHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateReceiverRequest(mux, decoder)
		encodeResponse = EncodeCreateReceiverResponse(encoder)
		encodeError    = EncodeCreateReceiverError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateReceiver")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateReceiverHandler configures the mux to serve the "buffer" service
// "UpdateReceiver" endpoint.
func MountUpdateReceiverHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/v1/receivers/{receiverId}", f)
}

// NewUpdateReceiverHandler creates a HTTP handler which loads the HTTP request
// and calls the "buffer" service "UpdateReceiver" endpoint.
func NewUpdateReceiverHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateReceiverRequest(mux, decoder)
		encodeResponse = EncodeUpdateReceiverResponse(encoder)
		encodeError    = EncodeUpdateReceiverError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateReceiver")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListReceiversHandler configures the mux to serve the "buffer" service
// "ListReceivers" endpoint.
func MountListReceiversHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/receivers", f)
}

// NewListReceiversHandler creates a HTTP handler which loads the HTTP request
// and calls the "buffer" service "ListReceivers" endpoint.
func NewListReceiversHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListReceiversRequest(mux, decoder)
		encodeResponse = EncodeListReceiversResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListReceivers")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetReceiverHandler configures the mux to serve the "buffer" service
// "GetReceiver" endpoint.
func MountGetReceiverHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/receivers/{receiverId}", f)
}

// NewGetReceiverHandler creates a HTTP handler which loads the HTTP request
// and calls the "buffer" service "GetReceiver" endpoint.
func NewGetReceiverHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetReceiverRequest(mux, decoder)
		encodeResponse = EncodeGetReceiverResponse(encoder)
		encodeError    = EncodeGetReceiverError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetReceiver")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteReceiverHandler configures the mux to serve the "buffer" service
// "DeleteReceiver" endpoint.
func MountDeleteReceiverHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/v1/receivers/{receiverId}", f)
}

// NewDeleteReceiverHandler creates a HTTP handler which loads the HTTP request
// and calls the "buffer" service "DeleteReceiver" endpoint.
func NewDeleteReceiverHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteReceiverRequest(mux, decoder)
		encodeResponse = EncodeDeleteReceiverResponse(encoder)
		encodeError    = EncodeDeleteReceiverError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteReceiver")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountRefreshReceiverTokensHandler configures the mux to serve the "buffer"
// service "RefreshReceiverTokens" endpoint.
func MountRefreshReceiverTokensHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/receivers/{receiverId}/tokens/refresh", f)
}

// NewRefreshReceiverTokensHandler creates a HTTP handler which loads the HTTP
// request and calls the "buffer" service "RefreshReceiverTokens" endpoint.
func NewRefreshReceiverTokensHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeRefreshReceiverTokensRequest(mux, decoder)
		encodeResponse = EncodeRefreshReceiverTokensResponse(encoder)
		encodeError    = EncodeRefreshReceiverTokensError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "RefreshReceiverTokens")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreateExportHandler configures the mux to serve the "buffer" service
// "CreateExport" endpoint.
func MountCreateExportHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/receivers/{receiverId}/exports", f)
}

// NewCreateExportHandler creates a HTTP handler which loads the HTTP request
// and calls the "buffer" service "CreateExport" endpoint.
func NewCreateExportHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateExportRequest(mux, decoder)
		encodeResponse = EncodeCreateExportResponse(encoder)
		encodeError    = EncodeCreateExportError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateExport")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetExportHandler configures the mux to serve the "buffer" service
// "GetExport" endpoint.
func MountGetExportHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/receivers/{receiverId}/exports/{exportId}", f)
}

// NewGetExportHandler creates a HTTP handler which loads the HTTP request and
// calls the "buffer" service "GetExport" endpoint.
func NewGetExportHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetExportRequest(mux, decoder)
		encodeResponse = EncodeGetExportResponse(encoder)
		encodeError    = EncodeGetExportError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetExport")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListExportsHandler configures the mux to serve the "buffer" service
// "ListExports" endpoint.
func MountListExportsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/receivers/{receiverId}/exports", f)
}

// NewListExportsHandler creates a HTTP handler which loads the HTTP request
// and calls the "buffer" service "ListExports" endpoint.
func NewListExportsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListExportsRequest(mux, decoder)
		encodeResponse = EncodeListExportsResponse(encoder)
		encodeError    = EncodeListExportsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListExports")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateExportHandler configures the mux to serve the "buffer" service
// "UpdateExport" endpoint.
func MountUpdateExportHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/v1/receivers/{receiverId}/exports/{exportId}", f)
}

// NewUpdateExportHandler creates a HTTP handler which loads the HTTP request
// and calls the "buffer" service "UpdateExport" endpoint.
func NewUpdateExportHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateExportRequest(mux, decoder)
		encodeResponse = EncodeUpdateExportResponse(encoder)
		encodeError    = EncodeUpdateExportError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateExport")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteExportHandler configures the mux to serve the "buffer" service
// "DeleteExport" endpoint.
func MountDeleteExportHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/v1/receivers/{receiverId}/exports/{exportId}", f)
}

// NewDeleteExportHandler creates a HTTP handler which loads the HTTP request
// and calls the "buffer" service "DeleteExport" endpoint.
func NewDeleteExportHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteExportRequest(mux, decoder)
		encodeResponse = EncodeDeleteExportResponse(encoder)
		encodeError    = EncodeDeleteExportError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteExport")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountImportHandler configures the mux to serve the "buffer" service "Import"
// endpoint.
func MountImportHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/import/{projectId}/{receiverId}/{secret}", f)
}

// NewImportHandler creates a HTTP handler which loads the HTTP request and
// calls the "buffer" service "Import" endpoint.
func NewImportHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeImportRequest(mux, decoder)
		encodeResponse = EncodeImportResponse(encoder)
		encodeError    = EncodeImportError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "Import")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		data := &buffer.ImportRequestData{Payload: payload.(*buffer.ImportPayload), Body: r.Body}
		res, err := endpoint(ctx, data)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetTaskHandler configures the mux to serve the "buffer" service
// "GetTask" endpoint.
func MountGetTaskHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleBufferOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/tasks/{*taskId}", f)
}

// NewGetTaskHandler creates a HTTP handler which loads the HTTP request and
// calls the "buffer" service "GetTask" endpoint.
func NewGetTaskHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetTaskRequest(mux, decoder)
		encodeResponse = EncodeGetTaskResponse(encoder)
		encodeError    = EncodeGetTaskError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetTask")
		ctx = context.WithValue(ctx, goa.ServiceKey, "buffer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountOpenapiJSON configures the mux to serve GET request made to
// "/v1/documentation/openapi.json".
func MountOpenapiJSON(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi.json", HandleBufferOrigin(h).ServeHTTP)
}

// MountOpenapiYaml configures the mux to serve GET request made to
// "/v1/documentation/openapi.yaml".
func MountOpenapiYaml(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi.yaml", HandleBufferOrigin(h).ServeHTTP)
}

// MountOpenapi3JSON configures the mux to serve GET request made to
// "/v1/documentation/openapi3.json".
func MountOpenapi3JSON(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi3.json", HandleBufferOrigin(h).ServeHTTP)
}

// MountOpenapi3Yaml configures the mux to serve GET request made to
// "/v1/documentation/openapi3.yaml".
func MountOpenapi3Yaml(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi3.yaml", HandleBufferOrigin(h).ServeHTTP)
}

// MountSwaggerUI configures the mux to serve GET request made to
// "/v1/documentation".
func MountSwaggerUI(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/", HandleBufferOrigin(h).ServeHTTP)
	mux.Handle("GET", "/v1/documentation/*path", HandleBufferOrigin(h).ServeHTTP)
}

// MountCORSHandler configures the mux to serve the CORS endpoints for the
// service buffer.
func MountCORSHandler(mux goahttp.Muxer, h http.Handler) {
	h = HandleBufferOrigin(h)
	mux.Handle("OPTIONS", "/", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1", h.ServeHTTP)
	mux.Handle("OPTIONS", "/health-check", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/receivers", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/receivers/{receiverId}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/receivers/{receiverId}/tokens/refresh", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/receivers/{receiverId}/exports", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/receivers/{receiverId}/exports/{exportId}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/import/{projectId}/{receiverId}/{secret}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/tasks/{*taskId}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi.json", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi.yaml", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi3.json", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi3.yaml", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/{*path}", h.ServeHTTP)
}

// NewCORSHandler creates a HTTP handler which returns a simple 200 response.
func NewCORSHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(200)
	})
}

// HandleBufferOrigin applies the CORS response headers corresponding to the
// origin for the service buffer.
func HandleBufferOrigin(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		origin := r.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			h.ServeHTTP(w, r)
			return
		}
		if cors.MatchOrigin(origin, "*") {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PATCH, DELETE")
				w.Header().Set("Access-Control-Allow-Headers", "Content-Type, X-StorageApi-Token")
			}
			h.ServeHTTP(w, r)
			return
		}
		h.ServeHTTP(w, r)
		return
	})
}
