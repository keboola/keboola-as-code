package dependencies

import (
	"sync"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/atomic"

	"github.com/keboola/keboola-as-code/internal/pkg/utils/errors"
)

func TestLazy_Set(t *testing.T) {
	t.Parallel()
	initFn := func() string {
		return "abc"
	}

	// Set value
	lazy := new(Lazy[string])
	lazy.Set("def")

	// Get value
	value := lazy.MustInitAndGet(initFn)

	// InitFn is not invoked, if value is already set
	assert.Equal(t, "def", value)
}

func TestLazy_InitAndGet(t *testing.T) {
	t.Parallel()
	initFn := func() (string, error) {
		return "abc", nil
	}

	// Value is generated by init fn
	lazy := new(Lazy[string])
	value, err := lazy.InitAndGet(initFn)
	require.NoError(t, err)
	assert.Equal(t, "abc", value)
}

//nolint:unparam
func TestLazy_InitAndGet_Parallel(t *testing.T) {
	t.Parallel()

	callCount := atomic.NewInt64(0)
	initFn := func() (string, error) {
		callCount.Inc()
		return "abc", nil
	}
	lazy := new(Lazy[string])

	// Call in parallel
	wg := &sync.WaitGroup{}
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			value, err := lazy.InitAndGet(initFn)
			require.NoError(t, err)
			assert.Equal(t, "abc", value)
		}()
	}
	wg.Wait()
	assert.Equal(t, int64(1), callCount.Load())
}

func TestLazy_InitAndGet_Error(t *testing.T) {
	t.Parallel()
	initFn := func() (string, error) {
		return "", errors.New("some error")
	}

	// Expected error
	lazy := new(Lazy[string])
	_, err := lazy.InitAndGet(initFn)
	require.Error(t, err)
	assert.Equal(t, "some error", err.Error())
}

func TestLazy_MustInitAndGet(t *testing.T) {
	t.Parallel()
	initFn := func() string {
		return "abc"
	}

	// Value is generated by init fn
	lazy := new(Lazy[string])
	value := lazy.MustInitAndGet(initFn)
	assert.Equal(t, "abc", value)
}
