// Package op wraps low-level etcd operations to more easily usable high-level operation.
//
// Main benefits:
//
//   - Processors/callbacks can be attached to operations.
//   - Operations can be easily merged into transactions, see TxnOp.
//   - AtomicOp provides atomic ReadAndUpdate pattern.
package op

import (
	"context"
	"reflect"

	"go.etcd.io/etcd/api/v3/etcdserverpb"
	etcd "go.etcd.io/etcd/client/v3"

	"github.com/keboola/keboola-as-code/internal/pkg/utils/errors"
)

// Op is common interface for all operations in the package.
// Each operation also implements "Do" and "WithProcessor" methods,
// but they differ in types of the return values.
type Op interface {
	Op(ctx context.Context) (LowLevelOp, error)
}

type LowLevelOp struct {
	// Op is a low-level etcd operation.
	Op etcd.Op
	// MapResponse is a callback used to map response from the Op.
	MapResponse MapFn
}

type MapFn func(ctx context.Context, raw RawResponse) (result any, err error)

type Header = etcdserverpb.ResponseHeader // shortcut

// WithResult is generic type for all typed operations in the package, it implements the Op interface.
// The R is the operation result type.
// The struct is immutable, see With* methods.
type WithResult[R any] struct {
	lowLevelFactory
	client     etcd.KV
	mapper     func(ctx context.Context, raw RawResponse) (result R, err error)
	processors []func(ctx context.Context, r *Result[R])
}

// LowLevelFactory creates a low-level etcd operation.
type LowLevelFactory func(ctx context.Context) (etcd.Op, error)

// HighLevelFactory creates a high-level etcd operation.
type HighLevelFactory func() (Op, error)

type lowLevelFactory = LowLevelFactory // alias for private embedding

func NewForType[R any](client etcd.KV, factory LowLevelFactory, mapper func(ctx context.Context, raw RawResponse) (result R, err error)) WithResult[R] {
	return WithResult[R]{client: client, lowLevelFactory: factory, mapper: mapper}
}

func (v WithResult[R]) Op(ctx context.Context) (out LowLevelOp, err error) {
	// Create low-level operation
	if out.Op, err = v.lowLevelFactory(ctx); err != nil {
		return out, err
	}

	// Register response mapper
	out.MapResponse = func(ctx context.Context, raw RawResponse) (result any, err error) {
		return v.mapResponse(ctx, raw).ResultOrErr()
	}

	return out, nil
}

// WithProcessor registers a processor callback that can read and modify the result.
// Processor IS NOT executed when the request to database fails.
// Processor IS executed if a logical error occurs, for example, one generated by a previous processor.
// Other With* methods, shortcuts for WithProcessor, are not executed on logical errors (Result.Err() != nil).
func (v WithResult[R]) WithProcessor(p func(ctx context.Context, result *Result[R])) WithResult[R] {
	v.processors = append(v.processors, p)
	return v
}

// WithResultTo is a shortcut for the WithProcessor.
// If no error occurred, the result of the operation is written to the target pointer,
// otherwise an empty value is written.
func (v WithResult[R]) WithResultTo(ptr *R) WithResult[R] {
	return v.WithProcessor(func(_ context.Context, r *Result[R]) {
		if r.Err() == nil {
			*ptr = r.result
		} else {
			var empty R
			*ptr = empty
		}
	})
}

// WithResultValidator is a shortcut for the WithProcessor.
// If no error occurred yet, then the callback can validate the result and return an error.
func (v WithResult[R]) WithResultValidator(fn func(R) error) WithResult[R] {
	return v.WithProcessor(func(_ context.Context, result *Result[R]) {
		if result.Err() == nil {
			if err := fn(result.Result()); err != nil {
				result.AddErr(err)
			}
		}
	})
}

// WithOnResult is a shortcut for the WithProcessor.
// If no error occurred yet, then the callback is executed with the result.
func (v WithResult[R]) WithOnResult(fn func(result R)) WithResult[R] {
	return v.WithProcessor(func(_ context.Context, result *Result[R]) {
		if result.Err() == nil {
			fn(result.result)
		}
	})
}

// WithEmptyResultAsError is a shortcut for the WithProcessor.
// If no error occurred yet and the result is an empty value for the R type (nil if it is a pointer),
// then the callback is executed and returned error is added to the Result.
func (v WithResult[R]) WithEmptyResultAsError(fn func() error) WithResult[R] {
	return v.WithProcessor(func(_ context.Context, result *Result[R]) {
		emptyValue := result.Err() == nil && reflect.ValueOf(result.result).IsZero()
		emptyValueErr := errors.As(result.Err(), &EmptyResultError{})
		if emptyValue || emptyValueErr {
			if err := fn(); err != nil {
				result.ResetErr()
				result.AddErr(err)
			}
		}
	})
}

func (v WithResult[R]) Do(ctx context.Context, opts ...Option) *Result[R] {
	// Create low-level operation
	op, err := v.Op(ctx)
	if err != nil {
		return newResult[R](nil).AddErr(err)
	}

	// Do with retry
	raw, err := DoWithRetry(ctx, v.client, op.Op, opts...)
	if err != nil {
		return newResult[R](nil).AddErr(err)
	}

	// Map the raw response
	return v.mapResponse(ctx, raw)
}

func (v WithResult[R]) mapResponse(ctx context.Context, raw RawResponse) *Result[R] {
	r := newResult[R](&raw)

	// Map response to the result value
	if value, err := v.mapper(ctx, raw); err == nil {
		r.SetResult(value)
	} else {
		r.AddErr(err)
	}

	// Invoke processors
	for _, p := range v.processors {
		p(ctx, r)
	}

	return r
}
