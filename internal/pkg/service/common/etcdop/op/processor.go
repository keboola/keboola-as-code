package op

import (
	"context"
	"reflect"

	"github.com/keboola/keboola-as-code/internal/pkg/utils/errors"
)

// processors are callbacks that can react on or modify the result of an operation.
type processors[R any] struct {
	callbacks []func(ctx context.Context, r *Result[R])
}

func (p processors[R]) invoke(ctx context.Context, r *Result[R]) {
	// Invoke processors
	for _, fn := range p.callbacks {
		fn(ctx, r)
	}
}

// WithProcessor registers a processor callback that can read and modify the result.
// Processor IS NOT executed when the request to database fails.
// Processor IS executed if a logical error occurs, for example, one generated by a previous processor.
// Other With* methods, shortcuts for WithProcessor, are not executed on logical errors (Result.Err() != nil).
func (p processors[R]) WithProcessor(fn func(ctx context.Context, result *Result[R])) processors[R] {
	p.callbacks = append(p.callbacks, fn)
	return p
}

// WithResultTo is a shortcut for the WithProcessor.
// If no error occurred, the result of the operation is written to the target pointer,
// otherwise an empty value is written.
func (p processors[R]) WithResultTo(ptr *R) processors[R] {
	return p.WithProcessor(func(_ context.Context, r *Result[R]) {
		if r.Err() == nil {
			*ptr = r.Result()
		} else {
			var empty R
			*ptr = empty
		}
	})
}

// WithResultValidator is a shortcut for the WithProcessor.
// If no error occurred yet, then the callback can validate the result and return an error.
func (p processors[R]) WithResultValidator(fn func(R) error) processors[R] {
	return p.WithProcessor(func(_ context.Context, result *Result[R]) {
		if result.Err() == nil {
			if err := fn(result.Result()); err != nil {
				result.AddErr(err)
			}
		}
	})
}

// WithOnResult is a shortcut for the WithProcessor.
// If no error occurred yet, then the callback is executed with the result.
func (p processors[R]) WithOnResult(fn func(result R)) processors[R] {
	return p.WithProcessor(func(_ context.Context, result *Result[R]) {
		if result.Err() == nil {
			fn(result.Result())
		}
	})
}

// WithNotEmptyResultAsError is a shortcut for the WithProcessor.
// If no error occurred yet and the result is NOT an empty value for the R type (nil if it is a pointer),
// then the callback is executed and returned error is added to the Result.
func (p processors[R]) WithNotEmptyResultAsError(fn func() error) processors[R] {
	return p.WithProcessor(func(_ context.Context, result *Result[R]) {
		// Empty value is expected, reset EmptyResultError
		if errors.As(result.Err(), &EmptyResultError{}) {
			result.ResetErr()
			return
		}

		// Found unexpected empty value and no other error
		emptyValue := result.result == nil || reflect.ValueOf(*result.result).IsZero()
		if !emptyValue && result.Err() == nil {
			if err := fn(); err != nil {
				result.ResetErr()
				result.AddErr(err)
			}
		}
	})
}

// WithEmptyResultAsError is a shortcut for the WithProcessor.
// If no error occurred yet and the result is an empty value for the R type (nil if it is a pointer),
// then the callback is executed and returned error is added to the Result.
func (p processors[R]) WithEmptyResultAsError(fn func() error) processors[R] {
	return p.WithProcessor(func(_ context.Context, result *Result[R]) {
		emptyValue := result.Err() == nil && (result.result == nil || reflect.ValueOf(*result.result).IsZero())
		emptyValueErr := errors.As(result.Err(), &EmptyResultError{})
		if emptyValue || emptyValueErr {
			if err := fn(); err != nil {
				result.ResetErr()
				result.AddErr(err)
			}
		}
	})
}
