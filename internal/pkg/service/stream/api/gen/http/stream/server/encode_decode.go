// Code generated by goa v3.16.1, DO NOT EDIT.
//
// stream HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/keboola/keboola-as-code/api/stream --output
// ./internal/pkg/service/stream/api

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strconv"
	"strings"
	"unicode/utf8"

	stream "github.com/keboola/keboola-as-code/internal/pkg/service/stream/api/gen/stream"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeAPIVersionIndexResponse returns an encoder for responses returned by
// the stream ApiVersionIndex endpoint.
func EncodeAPIVersionIndexResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.ServiceDetail)
		enc := encoder(ctx, w)
		body := NewAPIVersionIndexResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeHealthCheckResponse returns an encoder for responses returned by the
// stream HealthCheck endpoint.
func EncodeHealthCheckResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(string)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "text/plain")
		enc := encoder(ctx, w)
		body := res
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeCreateSourceResponse returns an encoder for responses returned by the
// stream CreateSource endpoint.
func EncodeCreateSourceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewCreateSourceResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeCreateSourceRequest returns a decoder for requests sent to the stream
// CreateSource endpoint.
func DecodeCreateSourceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreateSourceRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateSourceRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branchID        string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateSourcePayload(&body, branchID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeCreateSourceError returns an encoder for errors returned by the
// CreateSource stream endpoint.
func EncodeCreateSourceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceAlreadyExists":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusConflict
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateSourceStreamAPISourceAlreadyExistsResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "stream.api.resourceLimitReached":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusUnprocessableEntity
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateSourceStreamAPIResourceLimitReachedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnprocessableEntity)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateSourceResponse returns an encoder for responses returned by the
// stream UpdateSource endpoint.
func EncodeUpdateSourceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewUpdateSourceResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateSourceRequest returns a decoder for requests sent to the stream
// UpdateSource endpoint.
func DecodeUpdateSourceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateSourceRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateSourceRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branchID        string
			sourceID        string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateSourcePayload(&body, branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpdateSourceError returns an encoder for errors returned by the
// UpdateSource stream endpoint.
func EncodeUpdateSourceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSourceStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListSourcesResponse returns an encoder for responses returned by the
// stream ListSources endpoint.
func EncodeListSourcesResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.SourcesList)
		enc := encoder(ctx, w)
		body := NewListSourcesResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListSourcesRequest returns a decoder for requests sent to the stream
// ListSources endpoint.
func DecodeListSourcesRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sinceID         string
			limit           int
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		qp := r.URL.Query()
		sinceIDRaw := qp.Get("sinceId")
		if sinceIDRaw != "" {
			sinceID = sinceIDRaw
		}
		{
			limitRaw := qp.Get("limit")
			if limitRaw == "" {
				limit = 100
			} else {
				v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
				}
				limit = int(v)
			}
		}
		if limit < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1, true))
		}
		if limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 100, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewListSourcesPayload(branchID, sinceID, limit, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetSourceResponse returns an encoder for responses returned by the
// stream GetSource endpoint.
func EncodeGetSourceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Source)
		enc := encoder(ctx, w)
		body := NewGetSourceResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetSourceRequest returns a decoder for requests sent to the stream
// GetSource endpoint.
func DecodeGetSourceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetSourcePayload(branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetSourceError returns an encoder for errors returned by the GetSource
// stream endpoint.
func EncodeGetSourceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetSourceStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteSourceResponse returns an encoder for responses returned by the
// stream DeleteSource endpoint.
func EncodeDeleteSourceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusOK)
		return nil
	}
}

// DecodeDeleteSourceRequest returns a decoder for requests sent to the stream
// DeleteSource endpoint.
func DecodeDeleteSourceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteSourcePayload(branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeDeleteSourceError returns an encoder for errors returned by the
// DeleteSource stream endpoint.
func EncodeDeleteSourceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteSourceStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetSourceSettingsResponse returns an encoder for responses returned by
// the stream GetSourceSettings endpoint.
func EncodeGetSourceSettingsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.SettingsResult)
		enc := encoder(ctx, w)
		body := NewGetSourceSettingsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetSourceSettingsRequest returns a decoder for requests sent to the
// stream GetSourceSettings endpoint.
func DecodeGetSourceSettingsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetSourceSettingsPayload(branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetSourceSettingsError returns an encoder for errors returned by the
// GetSourceSettings stream endpoint.
func EncodeGetSourceSettingsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetSourceSettingsStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateSourceSettingsResponse returns an encoder for responses returned
// by the stream UpdateSourceSettings endpoint.
func EncodeUpdateSourceSettingsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.SettingsResult)
		enc := encoder(ctx, w)
		body := NewUpdateSourceSettingsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateSourceSettingsRequest returns a decoder for requests sent to the
// stream UpdateSourceSettings endpoint.
func DecodeUpdateSourceSettingsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateSourceSettingsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateSourceSettingsRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branchID        string
			sourceID        string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateSourceSettingsPayload(&body, branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpdateSourceSettingsError returns an encoder for errors returned by
// the UpdateSourceSettings stream endpoint.
func EncodeUpdateSourceSettingsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSourceSettingsStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.forbidden":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSourceSettingsStreamAPIForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeRefreshSourceTokensResponse returns an encoder for responses returned
// by the stream RefreshSourceTokens endpoint.
func EncodeRefreshSourceTokensResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Source)
		enc := encoder(ctx, w)
		body := NewRefreshSourceTokensResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeRefreshSourceTokensRequest returns a decoder for requests sent to the
// stream RefreshSourceTokens endpoint.
func DecodeRefreshSourceTokensRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewRefreshSourceTokensPayload(branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeRefreshSourceTokensError returns an encoder for errors returned by the
// RefreshSourceTokens stream endpoint.
func EncodeRefreshSourceTokensError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRefreshSourceTokensStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateSinkResponse returns an encoder for responses returned by the
// stream CreateSink endpoint.
func EncodeCreateSinkResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewCreateSinkResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeCreateSinkRequest returns a decoder for requests sent to the stream
// CreateSink endpoint.
func DecodeCreateSinkRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreateSinkRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateSinkRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branchID        string
			sourceID        string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateSinkPayload(&body, branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeCreateSinkError returns an encoder for errors returned by the
// CreateSink stream endpoint.
func EncodeCreateSinkError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateSinkStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkAlreadyExists":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusConflict
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateSinkStreamAPISinkAlreadyExistsResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "stream.api.resourceLimitReached":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusUnprocessableEntity
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateSinkStreamAPIResourceLimitReachedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnprocessableEntity)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetSinkResponse returns an encoder for responses returned by the
// stream GetSink endpoint.
func EncodeGetSinkResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Sink)
		enc := encoder(ctx, w)
		body := NewGetSinkResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetSinkRequest returns a decoder for requests sent to the stream
// GetSink endpoint.
func DecodeGetSinkRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			sinkID          string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		sinkID = params["sinkId"]
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetSinkPayload(branchID, sourceID, sinkID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetSinkError returns an encoder for errors returned by the GetSink
// stream endpoint.
func EncodeGetSinkError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetSinkStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetSinkStreamAPISinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetSinkSettingsResponse returns an encoder for responses returned by
// the stream GetSinkSettings endpoint.
func EncodeGetSinkSettingsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.SettingsResult)
		enc := encoder(ctx, w)
		body := NewGetSinkSettingsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetSinkSettingsRequest returns a decoder for requests sent to the
// stream GetSinkSettings endpoint.
func DecodeGetSinkSettingsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			sinkID          string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		sinkID = params["sinkId"]
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetSinkSettingsPayload(branchID, sourceID, sinkID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetSinkSettingsError returns an encoder for errors returned by the
// GetSinkSettings stream endpoint.
func EncodeGetSinkSettingsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetSinkSettingsStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetSinkSettingsStreamAPISinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateSinkSettingsResponse returns an encoder for responses returned
// by the stream UpdateSinkSettings endpoint.
func EncodeUpdateSinkSettingsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.SettingsResult)
		enc := encoder(ctx, w)
		body := NewUpdateSinkSettingsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateSinkSettingsRequest returns a decoder for requests sent to the
// stream UpdateSinkSettings endpoint.
func DecodeUpdateSinkSettingsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateSinkSettingsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateSinkSettingsRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branchID        string
			sourceID        string
			sinkID          string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		sinkID = params["sinkId"]
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateSinkSettingsPayload(&body, branchID, sourceID, sinkID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpdateSinkSettingsError returns an encoder for errors returned by the
// UpdateSinkSettings stream endpoint.
func EncodeUpdateSinkSettingsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSinkSettingsStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSinkSettingsStreamAPISinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.forbidden":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSinkSettingsStreamAPIForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListSinksResponse returns an encoder for responses returned by the
// stream ListSinks endpoint.
func EncodeListSinksResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.SinksList)
		enc := encoder(ctx, w)
		body := NewListSinksResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListSinksRequest returns a decoder for requests sent to the stream
// ListSinks endpoint.
func DecodeListSinksRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			sinceID         string
			limit           int
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		qp := r.URL.Query()
		sinceIDRaw := qp.Get("sinceId")
		if sinceIDRaw != "" {
			sinceID = sinceIDRaw
		}
		{
			limitRaw := qp.Get("limit")
			if limitRaw == "" {
				limit = 100
			} else {
				v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
				}
				limit = int(v)
			}
		}
		if limit < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1, true))
		}
		if limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 100, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewListSinksPayload(branchID, sourceID, sinceID, limit, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeListSinksError returns an encoder for errors returned by the ListSinks
// stream endpoint.
func EncodeListSinksError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListSinksStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateSinkResponse returns an encoder for responses returned by the
// stream UpdateSink endpoint.
func EncodeUpdateSinkResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewUpdateSinkResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateSinkRequest returns a decoder for requests sent to the stream
// UpdateSink endpoint.
func DecodeUpdateSinkRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateSinkRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateSinkRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branchID        string
			sourceID        string
			sinkID          string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		sinkID = params["sinkId"]
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateSinkPayload(&body, branchID, sourceID, sinkID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpdateSinkError returns an encoder for errors returned by the
// UpdateSink stream endpoint.
func EncodeUpdateSinkError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSinkStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSinkStreamAPISinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteSinkResponse returns an encoder for responses returned by the
// stream DeleteSink endpoint.
func EncodeDeleteSinkResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusOK)
		return nil
	}
}

// DecodeDeleteSinkRequest returns a decoder for requests sent to the stream
// DeleteSink endpoint.
func DecodeDeleteSinkRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			sinkID          string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		sinkID = params["sinkId"]
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteSinkPayload(branchID, sourceID, sinkID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeDeleteSinkError returns an encoder for errors returned by the
// DeleteSink stream endpoint.
func EncodeDeleteSinkError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteSinkStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteSinkStreamAPISinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeSinkStatisticsResponse returns an encoder for responses returned by
// the stream SinkStatistics endpoint.
func EncodeSinkStatisticsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.SinkStatisticsResult)
		enc := encoder(ctx, w)
		body := NewSinkStatisticsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeSinkStatisticsRequest returns a decoder for requests sent to the
// stream SinkStatistics endpoint.
func DecodeSinkStatisticsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID         string
			sourceID         string
			sinkID           string
			since            string
			until            string
			intervalDuration int64
			storageAPIToken  string
			err              error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		sinkID = params["sinkId"]
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		qp := r.URL.Query()
		since = qp.Get("since")
		if since == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("since", "query string"))
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("since", since, goa.FormatDateTime))
		until = qp.Get("until")
		if until == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("until", "query string"))
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("until", until, goa.FormatDateTime))
		{
			intervalDurationRaw := qp.Get("intervalDuration")
			if intervalDurationRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("intervalDuration", "query string"))
			}
			v, err2 := strconv.ParseInt(intervalDurationRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("intervalDuration", intervalDurationRaw, "integer"))
			}
			intervalDuration = v
		}
		if intervalDuration < 3.6e+12 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("intervalDuration", intervalDuration, 3.6e+12, true))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewSinkStatisticsPayload(branchID, sourceID, sinkID, since, until, intervalDuration, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeSinkStatisticsError returns an encoder for errors returned by the
// SinkStatistics stream endpoint.
func EncodeSinkStatisticsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSinkStatisticsStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSinkStatisticsStreamAPISinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.maximumIntervalLengthExceeded":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusUnprocessableEntity
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSinkStatisticsStreamAPIMaximumIntervalLengthExceededResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnprocessableEntity)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetTaskResponse returns an encoder for responses returned by the
// stream GetTask endpoint.
func EncodeGetTaskResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewGetTaskResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetTaskRequest returns a decoder for requests sent to the stream
// GetTask endpoint.
func DecodeGetTaskRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			taskID          string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		taskID = params["taskId"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetTaskPayload(taskID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetTaskError returns an encoder for errors returned by the GetTask
// stream endpoint.
func EncodeGetTaskError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.taskNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetTaskStreamAPITaskNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalStreamTaskOutputsToTaskOutputsResponseBody builds a value of type
// *TaskOutputsResponseBody from a value of type *stream.TaskOutputs.
func marshalStreamTaskOutputsToTaskOutputsResponseBody(v *stream.TaskOutputs) *TaskOutputsResponseBody {
	if v == nil {
		return nil
	}
	res := &TaskOutputsResponseBody{
		URL: v.URL,
	}
	if v.ProjectID != nil {
		projectID := int(*v.ProjectID)
		res.ProjectID = &projectID
	}
	if v.BranchID != nil {
		branchID := int(*v.BranchID)
		res.BranchID = &branchID
	}
	if v.SourceID != nil {
		sourceID := string(*v.SourceID)
		res.SourceID = &sourceID
	}
	if v.SinkID != nil {
		sinkID := string(*v.SinkID)
		res.SinkID = &sinkID
	}

	return res
}

// marshalStreamPaginatedResponseToPaginatedResponseResponseBody builds a value
// of type *PaginatedResponseResponseBody from a value of type
// *stream.PaginatedResponse.
func marshalStreamPaginatedResponseToPaginatedResponseResponseBody(v *stream.PaginatedResponse) *PaginatedResponseResponseBody {
	res := &PaginatedResponseResponseBody{
		Limit:      v.Limit,
		TotalCount: v.TotalCount,
		SinceID:    v.SinceID,
		LastID:     v.LastID,
	}

	return res
}

// marshalStreamSourceToSourceResponseBody builds a value of type
// *SourceResponseBody from a value of type *stream.Source.
func marshalStreamSourceToSourceResponseBody(v *stream.Source) *SourceResponseBody {
	res := &SourceResponseBody{
		ProjectID:   int(v.ProjectID),
		BranchID:    int(v.BranchID),
		SourceID:    string(v.SourceID),
		Type:        string(v.Type),
		Name:        v.Name,
		Description: v.Description,
	}
	if v.HTTP != nil {
		res.HTTP = marshalStreamHTTPSourceToHTTPSourceResponseBody(v.HTTP)
	}
	if v.Version != nil {
		res.Version = marshalStreamVersionToVersionResponseBody(v.Version)
	}
	if v.Deleted != nil {
		res.Deleted = marshalStreamDeletedEntityToDeletedEntityResponseBody(v.Deleted)
	}
	if v.Disabled != nil {
		res.Disabled = marshalStreamDisabledEntityToDisabledEntityResponseBody(v.Disabled)
	}
	if v.Sinks != nil {
		res.Sinks = make([]*SinkResponseBody, len(v.Sinks))
		for i, val := range v.Sinks {
			res.Sinks[i] = marshalStreamSinkToSinkResponseBody(val)
		}
	} else {
		res.Sinks = []*SinkResponseBody{}
	}

	return res
}

// marshalStreamHTTPSourceToHTTPSourceResponseBody builds a value of type
// *HTTPSourceResponseBody from a value of type *stream.HTTPSource.
func marshalStreamHTTPSourceToHTTPSourceResponseBody(v *stream.HTTPSource) *HTTPSourceResponseBody {
	if v == nil {
		return nil
	}
	res := &HTTPSourceResponseBody{
		URL: v.URL,
	}

	return res
}

// marshalStreamVersionToVersionResponseBody builds a value of type
// *VersionResponseBody from a value of type *stream.Version.
func marshalStreamVersionToVersionResponseBody(v *stream.Version) *VersionResponseBody {
	res := &VersionResponseBody{
		Number:      v.Number,
		Hash:        v.Hash,
		ModifiedAt:  v.ModifiedAt,
		Description: v.Description,
	}

	return res
}

// marshalStreamDeletedEntityToDeletedEntityResponseBody builds a value of type
// *DeletedEntityResponseBody from a value of type *stream.DeletedEntity.
func marshalStreamDeletedEntityToDeletedEntityResponseBody(v *stream.DeletedEntity) *DeletedEntityResponseBody {
	if v == nil {
		return nil
	}
	res := &DeletedEntityResponseBody{
		At: v.At,
	}
	if v.By != nil {
		res.By = marshalStreamByToByResponseBody(v.By)
	}

	return res
}

// marshalStreamByToByResponseBody builds a value of type *ByResponseBody from
// a value of type *stream.By.
func marshalStreamByToByResponseBody(v *stream.By) *ByResponseBody {
	res := &ByResponseBody{
		Type:            v.Type,
		TokenID:         v.TokenID,
		UserID:          v.UserID,
		UserDescription: v.UserDescription,
	}

	return res
}

// marshalStreamDisabledEntityToDisabledEntityResponseBody builds a value of
// type *DisabledEntityResponseBody from a value of type *stream.DisabledEntity.
func marshalStreamDisabledEntityToDisabledEntityResponseBody(v *stream.DisabledEntity) *DisabledEntityResponseBody {
	if v == nil {
		return nil
	}
	res := &DisabledEntityResponseBody{
		At:     v.At,
		Reason: v.Reason,
	}
	if v.By != nil {
		res.By = marshalStreamByToByResponseBody(v.By)
	}

	return res
}

// marshalStreamSinkToSinkResponseBody builds a value of type *SinkResponseBody
// from a value of type *stream.Sink.
func marshalStreamSinkToSinkResponseBody(v *stream.Sink) *SinkResponseBody {
	res := &SinkResponseBody{
		ProjectID:   int(v.ProjectID),
		BranchID:    int(v.BranchID),
		SourceID:    string(v.SourceID),
		SinkID:      string(v.SinkID),
		Name:        v.Name,
		Description: v.Description,
	}
	if v.Type != nil {
		type_ := string(*v.Type)
		res.Type = &type_
	}
	if v.Table != nil {
		res.Table = marshalStreamTableSinkToTableSinkResponseBody(v.Table)
	}
	if v.Version != nil {
		res.Version = marshalStreamVersionToVersionResponseBody(v.Version)
	}
	if v.Deleted != nil {
		res.Deleted = marshalStreamDeletedEntityToDeletedEntityResponseBody(v.Deleted)
	}
	if v.Disabled != nil {
		res.Disabled = marshalStreamDisabledEntityToDisabledEntityResponseBody(v.Disabled)
	}

	return res
}

// marshalStreamTableSinkToTableSinkResponseBody builds a value of type
// *TableSinkResponseBody from a value of type *stream.TableSink.
func marshalStreamTableSinkToTableSinkResponseBody(v *stream.TableSink) *TableSinkResponseBody {
	if v == nil {
		return nil
	}
	res := &TableSinkResponseBody{}
	if v.Mapping != nil {
		res.Mapping = marshalStreamTableMappingToTableMappingResponseBody(v.Mapping)
	}

	return res
}

// marshalStreamTableMappingToTableMappingResponseBody builds a value of type
// *TableMappingResponseBody from a value of type *stream.TableMapping.
func marshalStreamTableMappingToTableMappingResponseBody(v *stream.TableMapping) *TableMappingResponseBody {
	if v == nil {
		return nil
	}
	res := &TableMappingResponseBody{
		TableID: string(v.TableID),
	}
	if v.Columns != nil {
		res.Columns = make([]*TableColumnResponseBody, len(v.Columns))
		for i, val := range v.Columns {
			res.Columns[i] = marshalStreamTableColumnToTableColumnResponseBody(val)
		}
	} else {
		res.Columns = []*TableColumnResponseBody{}
	}

	return res
}

// marshalStreamTableColumnToTableColumnResponseBody builds a value of type
// *TableColumnResponseBody from a value of type *stream.TableColumn.
func marshalStreamTableColumnToTableColumnResponseBody(v *stream.TableColumn) *TableColumnResponseBody {
	res := &TableColumnResponseBody{
		PrimaryKey: v.PrimaryKey,
		Type:       v.Type,
		Name:       v.Name,
	}
	{
		var zero bool
		if res.PrimaryKey == zero {
			res.PrimaryKey = false
		}
	}
	if v.Template != nil {
		res.Template = marshalStreamTableColumnTemplateToTableColumnTemplateResponseBody(v.Template)
	}

	return res
}

// marshalStreamTableColumnTemplateToTableColumnTemplateResponseBody builds a
// value of type *TableColumnTemplateResponseBody from a value of type
// *stream.TableColumnTemplate.
func marshalStreamTableColumnTemplateToTableColumnTemplateResponseBody(v *stream.TableColumnTemplate) *TableColumnTemplateResponseBody {
	if v == nil {
		return nil
	}
	res := &TableColumnTemplateResponseBody{
		Language: v.Language,
		Content:  v.Content,
	}

	return res
}

// marshalStreamSettingResultToSettingResultResponseBody builds a value of type
// *SettingResultResponseBody from a value of type *stream.SettingResult.
func marshalStreamSettingResultToSettingResultResponseBody(v *stream.SettingResult) *SettingResultResponseBody {
	if v == nil {
		return nil
	}
	res := &SettingResultResponseBody{
		Key:          v.Key,
		Type:         v.Type,
		Description:  v.Description,
		Value:        v.Value,
		DefaultValue: v.DefaultValue,
		Overwritten:  v.Overwritten,
		Protected:    v.Protected,
		Validation:   v.Validation,
	}

	return res
}

// unmarshalSettingPatchRequestBodyToStreamSettingPatch builds a value of type
// *stream.SettingPatch from a value of type *SettingPatchRequestBody.
func unmarshalSettingPatchRequestBodyToStreamSettingPatch(v *SettingPatchRequestBody) *stream.SettingPatch {
	if v == nil {
		return nil
	}
	res := &stream.SettingPatch{
		Key:   *v.Key,
		Value: v.Value,
	}

	return res
}

// unmarshalTableSinkRequestBodyToStreamTableSink builds a value of type
// *stream.TableSink from a value of type *TableSinkRequestBody.
func unmarshalTableSinkRequestBodyToStreamTableSink(v *TableSinkRequestBody) *stream.TableSink {
	if v == nil {
		return nil
	}
	res := &stream.TableSink{}
	if v.Mapping != nil {
		res.Mapping = unmarshalTableMappingRequestBodyToStreamTableMapping(v.Mapping)
	}

	return res
}

// unmarshalTableMappingRequestBodyToStreamTableMapping builds a value of type
// *stream.TableMapping from a value of type *TableMappingRequestBody.
func unmarshalTableMappingRequestBodyToStreamTableMapping(v *TableMappingRequestBody) *stream.TableMapping {
	if v == nil {
		return nil
	}
	res := &stream.TableMapping{
		TableID: stream.TableID(*v.TableID),
	}
	res.Columns = make([]*stream.TableColumn, len(v.Columns))
	for i, val := range v.Columns {
		res.Columns[i] = unmarshalTableColumnRequestBodyToStreamTableColumn(val)
	}

	return res
}

// unmarshalTableColumnRequestBodyToStreamTableColumn builds a value of type
// *stream.TableColumn from a value of type *TableColumnRequestBody.
func unmarshalTableColumnRequestBodyToStreamTableColumn(v *TableColumnRequestBody) *stream.TableColumn {
	res := &stream.TableColumn{
		Type: *v.Type,
		Name: *v.Name,
	}
	if v.PrimaryKey != nil {
		res.PrimaryKey = *v.PrimaryKey
	}
	if v.PrimaryKey == nil {
		res.PrimaryKey = false
	}
	if v.Template != nil {
		res.Template = unmarshalTableColumnTemplateRequestBodyToStreamTableColumnTemplate(v.Template)
	}

	return res
}

// unmarshalTableColumnTemplateRequestBodyToStreamTableColumnTemplate builds a
// value of type *stream.TableColumnTemplate from a value of type
// *TableColumnTemplateRequestBody.
func unmarshalTableColumnTemplateRequestBodyToStreamTableColumnTemplate(v *TableColumnTemplateRequestBody) *stream.TableColumnTemplate {
	if v == nil {
		return nil
	}
	res := &stream.TableColumnTemplate{
		Language: *v.Language,
		Content:  *v.Content,
	}

	return res
}

// marshalStreamIntervalToIntervalResponseBody builds a value of type
// *IntervalResponseBody from a value of type *stream.Interval.
func marshalStreamIntervalToIntervalResponseBody(v *stream.Interval) *IntervalResponseBody {
	if v == nil {
		return nil
	}
	res := &IntervalResponseBody{
		Since: v.Since,
		Until: v.Until,
	}
	if v.Levels != nil {
		res.Levels = marshalStreamLevelsToLevelsResponseBody(v.Levels)
	}

	return res
}

// marshalStreamLevelsToLevelsResponseBody builds a value of type
// *LevelsResponseBody from a value of type *stream.Levels.
func marshalStreamLevelsToLevelsResponseBody(v *stream.Levels) *LevelsResponseBody {
	if v == nil {
		return nil
	}
	res := &LevelsResponseBody{}
	if v.Local != nil {
		res.Local = marshalStreamLevelToLevelResponseBody(v.Local)
	}
	if v.Staging != nil {
		res.Staging = marshalStreamLevelToLevelResponseBody(v.Staging)
	}
	if v.Target != nil {
		res.Target = marshalStreamLevelToLevelResponseBody(v.Target)
	}
	if v.Total != nil {
		res.Total = marshalStreamLevelToLevelResponseBody(v.Total)
	}

	return res
}

// marshalStreamLevelToLevelResponseBody builds a value of type
// *LevelResponseBody from a value of type *stream.Level.
func marshalStreamLevelToLevelResponseBody(v *stream.Level) *LevelResponseBody {
	if v == nil {
		return nil
	}
	res := &LevelResponseBody{
		RecordsCount:     v.RecordsCount,
		UncompressedSize: v.UncompressedSize,
	}

	return res
}
