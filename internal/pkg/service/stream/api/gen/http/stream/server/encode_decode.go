// Code generated by goa v3.16.1, DO NOT EDIT.
//
// stream HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/keboola/keboola-as-code/api/stream --output
// ./internal/pkg/service/stream/api

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strconv"
	"strings"
	"unicode/utf8"

	stream "github.com/keboola/keboola-as-code/internal/pkg/service/stream/api/gen/stream"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeAPIVersionIndexResponse returns an encoder for responses returned by
// the stream ApiVersionIndex endpoint.
func EncodeAPIVersionIndexResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.ServiceDetail)
		enc := encoder(ctx, w)
		body := NewAPIVersionIndexResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeHealthCheckResponse returns an encoder for responses returned by the
// stream HealthCheck endpoint.
func EncodeHealthCheckResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(string)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "text/plain")
		enc := encoder(ctx, w)
		body := res
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeCreateSourceResponse returns an encoder for responses returned by the
// stream CreateSource endpoint.
func EncodeCreateSourceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewCreateSourceResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeCreateSourceRequest returns a decoder for requests sent to the stream
// CreateSource endpoint.
func DecodeCreateSourceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreateSourceRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateSourceRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branchID        string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateSourcePayload(&body, branchID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeCreateSourceError returns an encoder for errors returned by the
// CreateSource stream endpoint.
func EncodeCreateSourceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceAlreadyExists":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusConflict
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateSourceStreamAPISourceAlreadyExistsResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "stream.api.resourceLimitReached":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusUnprocessableEntity
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateSourceStreamAPIResourceLimitReachedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnprocessableEntity)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateSourceResponse returns an encoder for responses returned by the
// stream UpdateSource endpoint.
func EncodeUpdateSourceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewUpdateSourceResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeUpdateSourceRequest returns a decoder for requests sent to the stream
// UpdateSource endpoint.
func DecodeUpdateSourceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateSourceRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateSourceRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branchID        string
			sourceID        string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateSourcePayload(&body, branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpdateSourceError returns an encoder for errors returned by the
// UpdateSource stream endpoint.
func EncodeUpdateSourceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSourceStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListSourcesResponse returns an encoder for responses returned by the
// stream ListSources endpoint.
func EncodeListSourcesResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.SourcesList)
		enc := encoder(ctx, w)
		body := NewListSourcesResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListSourcesRequest returns a decoder for requests sent to the stream
// ListSources endpoint.
func DecodeListSourcesRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sinceID         string
			limit           int
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		qp := r.URL.Query()
		sinceIDRaw := qp.Get("sinceId")
		if sinceIDRaw != "" {
			sinceID = sinceIDRaw
		}
		{
			limitRaw := qp.Get("limit")
			if limitRaw == "" {
				limit = 100
			} else {
				v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
				}
				limit = int(v)
			}
		}
		if limit < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1, true))
		}
		if limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 100, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewListSourcesPayload(branchID, sinceID, limit, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetSourceResponse returns an encoder for responses returned by the
// stream GetSource endpoint.
func EncodeGetSourceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Source)
		enc := encoder(ctx, w)
		body := NewGetSourceResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetSourceRequest returns a decoder for requests sent to the stream
// GetSource endpoint.
func DecodeGetSourceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetSourcePayload(branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetSourceError returns an encoder for errors returned by the GetSource
// stream endpoint.
func EncodeGetSourceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetSourceStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteSourceResponse returns an encoder for responses returned by the
// stream DeleteSource endpoint.
func EncodeDeleteSourceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewDeleteSourceResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeDeleteSourceRequest returns a decoder for requests sent to the stream
// DeleteSource endpoint.
func DecodeDeleteSourceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteSourcePayload(branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeDeleteSourceError returns an encoder for errors returned by the
// DeleteSource stream endpoint.
func EncodeDeleteSourceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteSourceStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetSourceSettingsResponse returns an encoder for responses returned by
// the stream GetSourceSettings endpoint.
func EncodeGetSourceSettingsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.SettingsResult)
		enc := encoder(ctx, w)
		body := NewGetSourceSettingsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetSourceSettingsRequest returns a decoder for requests sent to the
// stream GetSourceSettings endpoint.
func DecodeGetSourceSettingsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetSourceSettingsPayload(branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetSourceSettingsError returns an encoder for errors returned by the
// GetSourceSettings stream endpoint.
func EncodeGetSourceSettingsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetSourceSettingsStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateSourceSettingsResponse returns an encoder for responses returned
// by the stream UpdateSourceSettings endpoint.
func EncodeUpdateSourceSettingsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewUpdateSourceSettingsResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeUpdateSourceSettingsRequest returns a decoder for requests sent to the
// stream UpdateSourceSettings endpoint.
func DecodeUpdateSourceSettingsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateSourceSettingsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateSourceSettingsRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branchID        string
			sourceID        string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateSourceSettingsPayload(&body, branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpdateSourceSettingsError returns an encoder for errors returned by
// the UpdateSourceSettings stream endpoint.
func EncodeUpdateSourceSettingsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSourceSettingsStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.forbidden":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSourceSettingsStreamAPIForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeTestSourceResponse returns an encoder for responses returned by the
// stream TestSource endpoint.
func EncodeTestSourceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.TestResult)
		enc := encoder(ctx, w)
		body := NewTestSourceResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeTestSourceRequest returns a decoder for requests sent to the stream
// TestSource endpoint.
func DecodeTestSourceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewTestSourcePayload(branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeTestSourceError returns an encoder for errors returned by the
// TestSource stream endpoint.
func EncodeTestSourceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewTestSourceStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateSinkResponse returns an encoder for responses returned by the
// stream CreateSink endpoint.
func EncodeCreateSinkResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewCreateSinkResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeCreateSinkRequest returns a decoder for requests sent to the stream
// CreateSink endpoint.
func DecodeCreateSinkRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreateSinkRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateSinkRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branchID        string
			sourceID        string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateSinkPayload(&body, branchID, sourceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeCreateSinkError returns an encoder for errors returned by the
// CreateSink stream endpoint.
func EncodeCreateSinkError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateSinkStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkAlreadyExists":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusConflict
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateSinkStreamAPISinkAlreadyExistsResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "stream.api.resourceLimitReached":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusUnprocessableEntity
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateSinkStreamAPIResourceLimitReachedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnprocessableEntity)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetSinkResponse returns an encoder for responses returned by the
// stream GetSink endpoint.
func EncodeGetSinkResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Sink)
		enc := encoder(ctx, w)
		body := NewGetSinkResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetSinkRequest returns a decoder for requests sent to the stream
// GetSink endpoint.
func DecodeGetSinkRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			sinkID          string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		sinkID = params["sinkId"]
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetSinkPayload(branchID, sourceID, sinkID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetSinkError returns an encoder for errors returned by the GetSink
// stream endpoint.
func EncodeGetSinkError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetSinkStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetSinkStreamAPISinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetSinkSettingsResponse returns an encoder for responses returned by
// the stream GetSinkSettings endpoint.
func EncodeGetSinkSettingsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.SettingsResult)
		enc := encoder(ctx, w)
		body := NewGetSinkSettingsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetSinkSettingsRequest returns a decoder for requests sent to the
// stream GetSinkSettings endpoint.
func DecodeGetSinkSettingsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			sinkID          string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		sinkID = params["sinkId"]
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetSinkSettingsPayload(branchID, sourceID, sinkID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetSinkSettingsError returns an encoder for errors returned by the
// GetSinkSettings stream endpoint.
func EncodeGetSinkSettingsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetSinkSettingsStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetSinkSettingsStreamAPISinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateSinkSettingsResponse returns an encoder for responses returned
// by the stream UpdateSinkSettings endpoint.
func EncodeUpdateSinkSettingsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewUpdateSinkSettingsResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeUpdateSinkSettingsRequest returns a decoder for requests sent to the
// stream UpdateSinkSettings endpoint.
func DecodeUpdateSinkSettingsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateSinkSettingsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateSinkSettingsRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branchID        string
			sourceID        string
			sinkID          string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		sinkID = params["sinkId"]
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateSinkSettingsPayload(&body, branchID, sourceID, sinkID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpdateSinkSettingsError returns an encoder for errors returned by the
// UpdateSinkSettings stream endpoint.
func EncodeUpdateSinkSettingsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSinkSettingsStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSinkSettingsStreamAPISinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.forbidden":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSinkSettingsStreamAPIForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListSinksResponse returns an encoder for responses returned by the
// stream ListSinks endpoint.
func EncodeListSinksResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.SinksList)
		enc := encoder(ctx, w)
		body := NewListSinksResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListSinksRequest returns a decoder for requests sent to the stream
// ListSinks endpoint.
func DecodeListSinksRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			sinceID         string
			limit           int
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		qp := r.URL.Query()
		sinceIDRaw := qp.Get("sinceId")
		if sinceIDRaw != "" {
			sinceID = sinceIDRaw
		}
		{
			limitRaw := qp.Get("limit")
			if limitRaw == "" {
				limit = 100
			} else {
				v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
				}
				limit = int(v)
			}
		}
		if limit < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1, true))
		}
		if limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 100, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewListSinksPayload(branchID, sourceID, sinceID, limit, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeListSinksError returns an encoder for errors returned by the ListSinks
// stream endpoint.
func EncodeListSinksError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListSinksStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateSinkResponse returns an encoder for responses returned by the
// stream UpdateSink endpoint.
func EncodeUpdateSinkResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewUpdateSinkResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeUpdateSinkRequest returns a decoder for requests sent to the stream
// UpdateSink endpoint.
func DecodeUpdateSinkRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateSinkRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateSinkRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branchID        string
			sourceID        string
			sinkID          string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		sinkID = params["sinkId"]
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateSinkPayload(&body, branchID, sourceID, sinkID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpdateSinkError returns an encoder for errors returned by the
// UpdateSink stream endpoint.
func EncodeUpdateSinkError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSinkStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateSinkStreamAPISinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteSinkResponse returns an encoder for responses returned by the
// stream DeleteSink endpoint.
func EncodeDeleteSinkResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewDeleteSinkResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeDeleteSinkRequest returns a decoder for requests sent to the stream
// DeleteSink endpoint.
func DecodeDeleteSinkRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			sinkID          string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		sinkID = params["sinkId"]
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteSinkPayload(branchID, sourceID, sinkID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeDeleteSinkError returns an encoder for errors returned by the
// DeleteSink stream endpoint.
func EncodeDeleteSinkError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteSinkStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteSinkStreamAPISinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeSinkStatisticsTotalResponse returns an encoder for responses returned
// by the stream SinkStatisticsTotal endpoint.
func EncodeSinkStatisticsTotalResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.SinkStatisticsTotalResult)
		enc := encoder(ctx, w)
		body := NewSinkStatisticsTotalResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeSinkStatisticsTotalRequest returns a decoder for requests sent to the
// stream SinkStatisticsTotal endpoint.
func DecodeSinkStatisticsTotalRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			sinkID          string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		sinkID = params["sinkId"]
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewSinkStatisticsTotalPayload(branchID, sourceID, sinkID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeSinkStatisticsTotalError returns an encoder for errors returned by the
// SinkStatisticsTotal stream endpoint.
func EncodeSinkStatisticsTotalError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSinkStatisticsTotalStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSinkStatisticsTotalStreamAPISinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeSinkStatisticsFilesResponse returns an encoder for responses returned
// by the stream SinkStatisticsFiles endpoint.
func EncodeSinkStatisticsFilesResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.SinkStatisticsFilesResult)
		enc := encoder(ctx, w)
		body := NewSinkStatisticsFilesResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeSinkStatisticsFilesRequest returns a decoder for requests sent to the
// stream SinkStatisticsFiles endpoint.
func DecodeSinkStatisticsFilesRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branchID        string
			sourceID        string
			sinkID          string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branchID = params["branchId"]
		sourceID = params["sourceId"]
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		sinkID = params["sinkId"]
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewSinkStatisticsFilesPayload(branchID, sourceID, sinkID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeSinkStatisticsFilesError returns an encoder for errors returned by the
// SinkStatisticsFiles stream endpoint.
func EncodeSinkStatisticsFilesError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.sourceNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSinkStatisticsFilesStreamAPISourceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "stream.api.sinkNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSinkStatisticsFilesStreamAPISinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetTaskResponse returns an encoder for responses returned by the
// stream GetTask endpoint.
func EncodeGetTaskResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*stream.Task)
		enc := encoder(ctx, w)
		body := NewGetTaskResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetTaskRequest returns a decoder for requests sent to the stream
// GetTask endpoint.
func DecodeGetTaskRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			taskID          string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		taskID = params["taskId"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetTaskPayload(taskID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetTaskError returns an encoder for errors returned by the GetTask
// stream endpoint.
func EncodeGetTaskError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "stream.api.taskNotFound":
			var res *stream.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetTaskStreamAPITaskNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalStreamTaskOutputsToTaskOutputsResponseBody builds a value of type
// *TaskOutputsResponseBody from a value of type *stream.TaskOutputs.
func marshalStreamTaskOutputsToTaskOutputsResponseBody(v *stream.TaskOutputs) *TaskOutputsResponseBody {
	if v == nil {
		return nil
	}
	res := &TaskOutputsResponseBody{
		URL: v.URL,
	}
	if v.ProjectID != nil {
		projectID := int(*v.ProjectID)
		res.ProjectID = &projectID
	}
	if v.BranchID != nil {
		branchID := int(*v.BranchID)
		res.BranchID = &branchID
	}
	if v.SourceID != nil {
		sourceID := string(*v.SourceID)
		res.SourceID = &sourceID
	}
	if v.SinkID != nil {
		sinkID := string(*v.SinkID)
		res.SinkID = &sinkID
	}

	return res
}

// marshalStreamPaginatedResponseToPaginatedResponseResponseBody builds a value
// of type *PaginatedResponseResponseBody from a value of type
// *stream.PaginatedResponse.
func marshalStreamPaginatedResponseToPaginatedResponseResponseBody(v *stream.PaginatedResponse) *PaginatedResponseResponseBody {
	res := &PaginatedResponseResponseBody{
		Limit:      v.Limit,
		TotalCount: v.TotalCount,
		SinceID:    v.SinceID,
		LastID:     v.LastID,
	}

	return res
}

// marshalStreamSourceToSourceResponseBody builds a value of type
// *SourceResponseBody from a value of type *stream.Source.
func marshalStreamSourceToSourceResponseBody(v *stream.Source) *SourceResponseBody {
	res := &SourceResponseBody{
		ProjectID:   int(v.ProjectID),
		BranchID:    int(v.BranchID),
		SourceID:    string(v.SourceID),
		Type:        string(v.Type),
		Name:        v.Name,
		Description: v.Description,
	}
	if v.HTTP != nil {
		res.HTTP = marshalStreamHTTPSourceToHTTPSourceResponseBody(v.HTTP)
	}
	if v.Created != nil {
		res.Created = marshalStreamCreatedEntityToCreatedEntityResponseBody(v.Created)
	}
	if v.Version != nil {
		res.Version = marshalStreamVersionToVersionResponseBody(v.Version)
	}
	if v.Deleted != nil {
		res.Deleted = marshalStreamDeletedEntityToDeletedEntityResponseBody(v.Deleted)
	}
	if v.Disabled != nil {
		res.Disabled = marshalStreamDisabledEntityToDisabledEntityResponseBody(v.Disabled)
	}

	return res
}

// marshalStreamHTTPSourceToHTTPSourceResponseBody builds a value of type
// *HTTPSourceResponseBody from a value of type *stream.HTTPSource.
func marshalStreamHTTPSourceToHTTPSourceResponseBody(v *stream.HTTPSource) *HTTPSourceResponseBody {
	if v == nil {
		return nil
	}
	res := &HTTPSourceResponseBody{
		URL: v.URL,
	}

	return res
}

// marshalStreamCreatedEntityToCreatedEntityResponseBody builds a value of type
// *CreatedEntityResponseBody from a value of type *stream.CreatedEntity.
func marshalStreamCreatedEntityToCreatedEntityResponseBody(v *stream.CreatedEntity) *CreatedEntityResponseBody {
	res := &CreatedEntityResponseBody{
		At: v.At,
	}
	if v.By != nil {
		res.By = marshalStreamByToByResponseBody(v.By)
	}

	return res
}

// marshalStreamByToByResponseBody builds a value of type *ByResponseBody from
// a value of type *stream.By.
func marshalStreamByToByResponseBody(v *stream.By) *ByResponseBody {
	res := &ByResponseBody{
		Type:      v.Type,
		TokenID:   v.TokenID,
		TokenDesc: v.TokenDesc,
		UserID:    v.UserID,
		UserName:  v.UserName,
	}

	return res
}

// marshalStreamVersionToVersionResponseBody builds a value of type
// *VersionResponseBody from a value of type *stream.Version.
func marshalStreamVersionToVersionResponseBody(v *stream.Version) *VersionResponseBody {
	res := &VersionResponseBody{
		Number:      v.Number,
		Hash:        v.Hash,
		Description: v.Description,
		At:          v.At,
	}
	if v.By != nil {
		res.By = marshalStreamByToByResponseBody(v.By)
	}

	return res
}

// marshalStreamDeletedEntityToDeletedEntityResponseBody builds a value of type
// *DeletedEntityResponseBody from a value of type *stream.DeletedEntity.
func marshalStreamDeletedEntityToDeletedEntityResponseBody(v *stream.DeletedEntity) *DeletedEntityResponseBody {
	if v == nil {
		return nil
	}
	res := &DeletedEntityResponseBody{
		At: v.At,
	}
	if v.By != nil {
		res.By = marshalStreamByToByResponseBody(v.By)
	}

	return res
}

// marshalStreamDisabledEntityToDisabledEntityResponseBody builds a value of
// type *DisabledEntityResponseBody from a value of type *stream.DisabledEntity.
func marshalStreamDisabledEntityToDisabledEntityResponseBody(v *stream.DisabledEntity) *DisabledEntityResponseBody {
	if v == nil {
		return nil
	}
	res := &DisabledEntityResponseBody{
		At:     v.At,
		Reason: v.Reason,
	}
	if v.By != nil {
		res.By = marshalStreamByToByResponseBody(v.By)
	}

	return res
}

// marshalStreamSettingResultToSettingResultResponseBody builds a value of type
// *SettingResultResponseBody from a value of type *stream.SettingResult.
func marshalStreamSettingResultToSettingResultResponseBody(v *stream.SettingResult) *SettingResultResponseBody {
	if v == nil {
		return nil
	}
	res := &SettingResultResponseBody{
		Key:          v.Key,
		Type:         v.Type,
		Description:  v.Description,
		Value:        v.Value,
		DefaultValue: v.DefaultValue,
		Overwritten:  v.Overwritten,
		Protected:    v.Protected,
		Validation:   v.Validation,
	}

	return res
}

// unmarshalSettingPatchRequestBodyToStreamSettingPatch builds a value of type
// *stream.SettingPatch from a value of type *SettingPatchRequestBody.
func unmarshalSettingPatchRequestBodyToStreamSettingPatch(v *SettingPatchRequestBody) *stream.SettingPatch {
	if v == nil {
		return nil
	}
	res := &stream.SettingPatch{
		Key:   *v.Key,
		Value: v.Value,
	}

	return res
}

// marshalStreamTestResultTableToTestResultTableResponseBody builds a value of
// type *TestResultTableResponseBody from a value of type
// *stream.TestResultTable.
func marshalStreamTestResultTableToTestResultTableResponseBody(v *stream.TestResultTable) *TestResultTableResponseBody {
	res := &TestResultTableResponseBody{
		SinkID:  string(v.SinkID),
		TableID: string(v.TableID),
	}
	if v.Rows != nil {
		res.Rows = make([]*TestResultRowResponseBody, len(v.Rows))
		for i, val := range v.Rows {
			res.Rows[i] = marshalStreamTestResultRowToTestResultRowResponseBody(val)
		}
	} else {
		res.Rows = []*TestResultRowResponseBody{}
	}

	return res
}

// marshalStreamTestResultRowToTestResultRowResponseBody builds a value of type
// *TestResultRowResponseBody from a value of type *stream.TestResultRow.
func marshalStreamTestResultRowToTestResultRowResponseBody(v *stream.TestResultRow) *TestResultRowResponseBody {
	res := &TestResultRowResponseBody{}
	if v.Columns != nil {
		res.Columns = make([]*TestResultColumnResponseBody, len(v.Columns))
		for i, val := range v.Columns {
			res.Columns[i] = marshalStreamTestResultColumnToTestResultColumnResponseBody(val)
		}
	} else {
		res.Columns = []*TestResultColumnResponseBody{}
	}

	return res
}

// marshalStreamTestResultColumnToTestResultColumnResponseBody builds a value
// of type *TestResultColumnResponseBody from a value of type
// *stream.TestResultColumn.
func marshalStreamTestResultColumnToTestResultColumnResponseBody(v *stream.TestResultColumn) *TestResultColumnResponseBody {
	res := &TestResultColumnResponseBody{
		Name:  v.Name,
		Value: v.Value,
	}

	return res
}

// unmarshalTableSinkCreateRequestBodyToStreamTableSinkCreate builds a value of
// type *stream.TableSinkCreate from a value of type
// *TableSinkCreateRequestBody.
func unmarshalTableSinkCreateRequestBodyToStreamTableSinkCreate(v *TableSinkCreateRequestBody) *stream.TableSinkCreate {
	if v == nil {
		return nil
	}
	res := &stream.TableSinkCreate{
		Type:    stream.TableType(*v.Type),
		TableID: stream.TableID(*v.TableID),
	}
	res.Mapping = unmarshalTableMappingRequestBodyToStreamTableMapping(v.Mapping)

	return res
}

// unmarshalTableMappingRequestBodyToStreamTableMapping builds a value of type
// *stream.TableMapping from a value of type *TableMappingRequestBody.
func unmarshalTableMappingRequestBodyToStreamTableMapping(v *TableMappingRequestBody) *stream.TableMapping {
	res := &stream.TableMapping{}
	res.Columns = make([]*stream.TableColumn, len(v.Columns))
	for i, val := range v.Columns {
		res.Columns[i] = unmarshalTableColumnRequestBodyToStreamTableColumn(val)
	}

	return res
}

// unmarshalTableColumnRequestBodyToStreamTableColumn builds a value of type
// *stream.TableColumn from a value of type *TableColumnRequestBody.
func unmarshalTableColumnRequestBodyToStreamTableColumn(v *TableColumnRequestBody) *stream.TableColumn {
	res := &stream.TableColumn{
		Type: *v.Type,
		Name: *v.Name,
	}
	if v.PrimaryKey != nil {
		res.PrimaryKey = *v.PrimaryKey
	}
	if v.PrimaryKey == nil {
		res.PrimaryKey = false
	}
	if v.Template != nil {
		res.Template = unmarshalTableColumnTemplateRequestBodyToStreamTableColumnTemplate(v.Template)
	}

	return res
}

// unmarshalTableColumnTemplateRequestBodyToStreamTableColumnTemplate builds a
// value of type *stream.TableColumnTemplate from a value of type
// *TableColumnTemplateRequestBody.
func unmarshalTableColumnTemplateRequestBodyToStreamTableColumnTemplate(v *TableColumnTemplateRequestBody) *stream.TableColumnTemplate {
	if v == nil {
		return nil
	}
	res := &stream.TableColumnTemplate{
		Language: *v.Language,
		Content:  *v.Content,
	}

	return res
}

// marshalStreamTableSinkToTableSinkResponseBody builds a value of type
// *TableSinkResponseBody from a value of type *stream.TableSink.
func marshalStreamTableSinkToTableSinkResponseBody(v *stream.TableSink) *TableSinkResponseBody {
	if v == nil {
		return nil
	}
	res := &TableSinkResponseBody{
		Type:    string(v.Type),
		TableID: string(v.TableID),
	}
	if v.Mapping != nil {
		res.Mapping = marshalStreamTableMappingToTableMappingResponseBody(v.Mapping)
	}

	return res
}

// marshalStreamTableMappingToTableMappingResponseBody builds a value of type
// *TableMappingResponseBody from a value of type *stream.TableMapping.
func marshalStreamTableMappingToTableMappingResponseBody(v *stream.TableMapping) *TableMappingResponseBody {
	res := &TableMappingResponseBody{}
	if v.Columns != nil {
		res.Columns = make([]*TableColumnResponseBody, len(v.Columns))
		for i, val := range v.Columns {
			res.Columns[i] = marshalStreamTableColumnToTableColumnResponseBody(val)
		}
	} else {
		res.Columns = []*TableColumnResponseBody{}
	}

	return res
}

// marshalStreamTableColumnToTableColumnResponseBody builds a value of type
// *TableColumnResponseBody from a value of type *stream.TableColumn.
func marshalStreamTableColumnToTableColumnResponseBody(v *stream.TableColumn) *TableColumnResponseBody {
	res := &TableColumnResponseBody{
		PrimaryKey: v.PrimaryKey,
		Type:       v.Type,
		Name:       v.Name,
	}
	{
		var zero bool
		if res.PrimaryKey == zero {
			res.PrimaryKey = false
		}
	}
	if v.Template != nil {
		res.Template = marshalStreamTableColumnTemplateToTableColumnTemplateResponseBody(v.Template)
	}

	return res
}

// marshalStreamTableColumnTemplateToTableColumnTemplateResponseBody builds a
// value of type *TableColumnTemplateResponseBody from a value of type
// *stream.TableColumnTemplate.
func marshalStreamTableColumnTemplateToTableColumnTemplateResponseBody(v *stream.TableColumnTemplate) *TableColumnTemplateResponseBody {
	if v == nil {
		return nil
	}
	res := &TableColumnTemplateResponseBody{
		Language: v.Language,
		Content:  v.Content,
	}

	return res
}

// marshalStreamSinkToSinkResponseBody builds a value of type *SinkResponseBody
// from a value of type *stream.Sink.
func marshalStreamSinkToSinkResponseBody(v *stream.Sink) *SinkResponseBody {
	res := &SinkResponseBody{
		ProjectID:   int(v.ProjectID),
		BranchID:    int(v.BranchID),
		SourceID:    string(v.SourceID),
		SinkID:      string(v.SinkID),
		Type:        string(v.Type),
		Name:        v.Name,
		Description: v.Description,
	}
	if v.Table != nil {
		res.Table = marshalStreamTableSinkToTableSinkResponseBody(v.Table)
	}
	if v.Version != nil {
		res.Version = marshalStreamVersionToVersionResponseBody(v.Version)
	}
	if v.Created != nil {
		res.Created = marshalStreamCreatedEntityToCreatedEntityResponseBody(v.Created)
	}
	if v.Deleted != nil {
		res.Deleted = marshalStreamDeletedEntityToDeletedEntityResponseBody(v.Deleted)
	}
	if v.Disabled != nil {
		res.Disabled = marshalStreamDisabledEntityToDisabledEntityResponseBody(v.Disabled)
	}

	return res
}

// unmarshalTableSinkUpdateRequestBodyToStreamTableSinkUpdate builds a value of
// type *stream.TableSinkUpdate from a value of type
// *TableSinkUpdateRequestBody.
func unmarshalTableSinkUpdateRequestBodyToStreamTableSinkUpdate(v *TableSinkUpdateRequestBody) *stream.TableSinkUpdate {
	if v == nil {
		return nil
	}
	res := &stream.TableSinkUpdate{}
	if v.Type != nil {
		type_ := stream.TableType(*v.Type)
		res.Type = &type_
	}
	if v.TableID != nil {
		tableID := stream.TableID(*v.TableID)
		res.TableID = &tableID
	}
	if v.Mapping != nil {
		res.Mapping = unmarshalTableMappingRequestBodyToStreamTableMapping(v.Mapping)
	}

	return res
}

// marshalStreamLevelToLevelResponseBody builds a value of type
// *LevelResponseBody from a value of type *stream.Level.
func marshalStreamLevelToLevelResponseBody(v *stream.Level) *LevelResponseBody {
	res := &LevelResponseBody{
		FirstRecordAt:    v.FirstRecordAt,
		LastRecordAt:     v.LastRecordAt,
		RecordsCount:     v.RecordsCount,
		UncompressedSize: v.UncompressedSize,
	}

	return res
}

// marshalStreamLevelsToLevelsResponseBody builds a value of type
// *LevelsResponseBody from a value of type *stream.Levels.
func marshalStreamLevelsToLevelsResponseBody(v *stream.Levels) *LevelsResponseBody {
	res := &LevelsResponseBody{}
	if v.Local != nil {
		res.Local = marshalStreamLevelToLevelResponseBody(v.Local)
	}
	if v.Staging != nil {
		res.Staging = marshalStreamLevelToLevelResponseBody(v.Staging)
	}
	if v.Target != nil {
		res.Target = marshalStreamLevelToLevelResponseBody(v.Target)
	}

	return res
}

// marshalStreamSinkFileToSinkFileResponseBody builds a value of type
// *SinkFileResponseBody from a value of type *stream.SinkFile.
func marshalStreamSinkFileToSinkFileResponseBody(v *stream.SinkFile) *SinkFileResponseBody {
	res := &SinkFileResponseBody{
		State:       string(v.State),
		OpenedAt:    v.OpenedAt,
		ClosingAt:   v.ClosingAt,
		ImportingAt: v.ImportingAt,
		ImportedAt:  v.ImportedAt,
	}
	if v.Statistics != nil {
		res.Statistics = marshalStreamSinkFileStatisticsToSinkFileStatisticsResponseBody(v.Statistics)
	}

	return res
}

// marshalStreamSinkFileStatisticsToSinkFileStatisticsResponseBody builds a
// value of type *SinkFileStatisticsResponseBody from a value of type
// *stream.SinkFileStatistics.
func marshalStreamSinkFileStatisticsToSinkFileStatisticsResponseBody(v *stream.SinkFileStatistics) *SinkFileStatisticsResponseBody {
	res := &SinkFileStatisticsResponseBody{}
	if v.Total != nil {
		res.Total = marshalStreamLevelToLevelResponseBody(v.Total)
	}
	if v.Levels != nil {
		res.Levels = marshalStreamLevelsToLevelsResponseBody(v.Levels)
	}

	return res
}
