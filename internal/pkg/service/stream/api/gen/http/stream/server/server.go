// Code generated by goa v3.19.1, DO NOT EDIT.
//
// stream HTTP server
//
// Command:
// $ goa gen github.com/keboola/keboola-as-code/api/stream --output
// ./internal/pkg/service/stream/api

package server

import (
	"context"
	"net/http"
	"path"

	stream "github.com/keboola/keboola-as-code/internal/pkg/service/stream/api/gen/stream"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
	"goa.design/plugins/v3/cors"
)

// Server lists the stream service endpoint HTTP handlers.
type Server struct {
	Mounts                []*MountPoint
	APIRootIndex          http.Handler
	APIVersionIndex       http.Handler
	HealthCheck           http.Handler
	CreateSource          http.Handler
	UpdateSource          http.Handler
	ListSources           http.Handler
	GetSource             http.Handler
	DeleteSource          http.Handler
	GetSourceSettings     http.Handler
	UpdateSourceSettings  http.Handler
	TestSource            http.Handler
	SourceStatisticsClear http.Handler
	DisableSource         http.Handler
	EnableSource          http.Handler
	ListSourceVersions    http.Handler
	SourceVersionDetail   http.Handler
	RollbackSourceVersion http.Handler
	CreateSink            http.Handler
	GetSink               http.Handler
	GetSinkSettings       http.Handler
	UpdateSinkSettings    http.Handler
	ListSinks             http.Handler
	UpdateSink            http.Handler
	DeleteSink            http.Handler
	SinkStatisticsTotal   http.Handler
	SinkStatisticsFiles   http.Handler
	SinkStatisticsClear   http.Handler
	DisableSink           http.Handler
	EnableSink            http.Handler
	ListSinkVersions      http.Handler
	SinkVersionDetail     http.Handler
	GetTask               http.Handler
	AggregationSources    http.Handler
	CORS                  http.Handler
	OpenapiJSON           http.Handler
	OpenapiYaml           http.Handler
	Openapi3JSON          http.Handler
	Openapi3Yaml          http.Handler
	SwaggerUI             http.Handler
}

// MountPoint holds information about the mounted endpoints.
type MountPoint struct {
	// Method is the name of the service method served by the mounted HTTP handler.
	Method string
	// Verb is the HTTP method used to match requests to the mounted handler.
	Verb string
	// Pattern is the HTTP request path pattern used to match requests to the
	// mounted handler.
	Pattern string
}

// New instantiates HTTP handlers for all the stream service endpoints using
// the provided encoder and decoder. The handlers are mounted on the given mux
// using the HTTP verb and path defined in the design. errhandler is called
// whenever a response fails to be encoded. formatter is used to format errors
// returned by the service methods prior to encoding. Both errhandler and
// formatter are optional and can be nil.
func New(
	e *stream.Endpoints,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
	fileSystemOpenapiJSON http.FileSystem,
	fileSystemOpenapiYaml http.FileSystem,
	fileSystemOpenapi3JSON http.FileSystem,
	fileSystemOpenapi3Yaml http.FileSystem,
	fileSystemSwaggerUI http.FileSystem,
) *Server {
	if fileSystemOpenapiJSON == nil {
		fileSystemOpenapiJSON = http.Dir(".")
	}
	if fileSystemOpenapiYaml == nil {
		fileSystemOpenapiYaml = http.Dir(".")
	}
	if fileSystemOpenapi3JSON == nil {
		fileSystemOpenapi3JSON = http.Dir(".")
	}
	if fileSystemOpenapi3Yaml == nil {
		fileSystemOpenapi3Yaml = http.Dir(".")
	}
	if fileSystemSwaggerUI == nil {
		fileSystemSwaggerUI = http.Dir(".")
	}
	fileSystemSwaggerUI = appendPrefix(fileSystemSwaggerUI, "/swagger-ui")
	return &Server{
		Mounts: []*MountPoint{
			{"APIRootIndex", "GET", "/"},
			{"APIVersionIndex", "GET", "/v1"},
			{"HealthCheck", "GET", "/health-check"},
			{"CreateSource", "POST", "/v1/branches/{branchId}/sources"},
			{"UpdateSource", "PATCH", "/v1/branches/{branchId}/sources/{sourceId}"},
			{"ListSources", "GET", "/v1/branches/{branchId}/sources"},
			{"GetSource", "GET", "/v1/branches/{branchId}/sources/{sourceId}"},
			{"DeleteSource", "DELETE", "/v1/branches/{branchId}/sources/{sourceId}"},
			{"GetSourceSettings", "GET", "/v1/branches/{branchId}/sources/{sourceId}/settings"},
			{"UpdateSourceSettings", "PATCH", "/v1/branches/{branchId}/sources/{sourceId}/settings"},
			{"TestSource", "POST", "/v1/branches/{branchId}/sources/{sourceId}/test"},
			{"SourceStatisticsClear", "DELETE", "/v1/branches/{branchId}/sources/{sourceId}/statistics/clear"},
			{"DisableSource", "PUT", "/v1/branches/{branchId}/sources/{sourceId}/disable"},
			{"EnableSource", "PUT", "/v1/branches/{branchId}/sources/{sourceId}/enable"},
			{"ListSourceVersions", "GET", "/v1/branches/{branchId}/sources/{sourceId}/versions"},
			{"SourceVersionDetail", "GET", "/v1/branches/{branchId}/sources/{sourceId}/versions/{versionNumber}"},
			{"RollbackSourceVersion", "PUT", "/v1/branches/{branchId}/sources/{sourceId}/versions/{versionNumber}/rollback"},
			{"CreateSink", "POST", "/v1/branches/{branchId}/sources/{sourceId}/sinks"},
			{"GetSink", "GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}"},
			{"GetSinkSettings", "GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/settings"},
			{"UpdateSinkSettings", "PATCH", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/settings"},
			{"ListSinks", "GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks"},
			{"UpdateSink", "PATCH", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}"},
			{"DeleteSink", "DELETE", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}"},
			{"SinkStatisticsTotal", "GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/total"},
			{"SinkStatisticsFiles", "GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/files"},
			{"SinkStatisticsClear", "DELETE", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/clear"},
			{"DisableSink", "PUT", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/disable"},
			{"EnableSink", "PUT", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/enable"},
			{"ListSinkVersions", "GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/versions"},
			{"SinkVersionDetail", "GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/versions/{versionNumber}"},
			{"GetTask", "GET", "/v1/tasks/{*taskId}"},
			{"AggregationSources", "GET", "/v1/branches/{branchId}/aggregation/sources"},
			{"CORS", "OPTIONS", "/"},
			{"CORS", "OPTIONS", "/v1"},
			{"CORS", "OPTIONS", "/health-check"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/settings"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/test"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/statistics/clear"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/disable"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/enable"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/versions"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/versions/{versionNumber}"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/versions/{versionNumber}/rollback"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/settings"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/total"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/files"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/clear"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/disable"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/enable"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/versions"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/versions/{versionNumber}"},
			{"CORS", "OPTIONS", "/v1/tasks/{*taskId}"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/aggregation/sources"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi.json"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi.yaml"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi3.json"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi3.yaml"},
			{"CORS", "OPTIONS", "/v1/documentation/{*path}"},
			{"Serve openapi.json", "GET", "/v1/documentation/openapi.json"},
			{"Serve openapi.yaml", "GET", "/v1/documentation/openapi.yaml"},
			{"Serve openapi3.json", "GET", "/v1/documentation/openapi3.json"},
			{"Serve openapi3.yaml", "GET", "/v1/documentation/openapi3.yaml"},
			{"Serve swagger-ui", "GET", "/v1/documentation"},
		},
		APIRootIndex:          NewAPIRootIndexHandler(e.APIRootIndex, mux, decoder, encoder, errhandler, formatter),
		APIVersionIndex:       NewAPIVersionIndexHandler(e.APIVersionIndex, mux, decoder, encoder, errhandler, formatter),
		HealthCheck:           NewHealthCheckHandler(e.HealthCheck, mux, decoder, encoder, errhandler, formatter),
		CreateSource:          NewCreateSourceHandler(e.CreateSource, mux, decoder, encoder, errhandler, formatter),
		UpdateSource:          NewUpdateSourceHandler(e.UpdateSource, mux, decoder, encoder, errhandler, formatter),
		ListSources:           NewListSourcesHandler(e.ListSources, mux, decoder, encoder, errhandler, formatter),
		GetSource:             NewGetSourceHandler(e.GetSource, mux, decoder, encoder, errhandler, formatter),
		DeleteSource:          NewDeleteSourceHandler(e.DeleteSource, mux, decoder, encoder, errhandler, formatter),
		GetSourceSettings:     NewGetSourceSettingsHandler(e.GetSourceSettings, mux, decoder, encoder, errhandler, formatter),
		UpdateSourceSettings:  NewUpdateSourceSettingsHandler(e.UpdateSourceSettings, mux, decoder, encoder, errhandler, formatter),
		TestSource:            NewTestSourceHandler(e.TestSource, mux, decoder, encoder, errhandler, formatter),
		SourceStatisticsClear: NewSourceStatisticsClearHandler(e.SourceStatisticsClear, mux, decoder, encoder, errhandler, formatter),
		DisableSource:         NewDisableSourceHandler(e.DisableSource, mux, decoder, encoder, errhandler, formatter),
		EnableSource:          NewEnableSourceHandler(e.EnableSource, mux, decoder, encoder, errhandler, formatter),
		ListSourceVersions:    NewListSourceVersionsHandler(e.ListSourceVersions, mux, decoder, encoder, errhandler, formatter),
		SourceVersionDetail:   NewSourceVersionDetailHandler(e.SourceVersionDetail, mux, decoder, encoder, errhandler, formatter),
		RollbackSourceVersion: NewRollbackSourceVersionHandler(e.RollbackSourceVersion, mux, decoder, encoder, errhandler, formatter),
		CreateSink:            NewCreateSinkHandler(e.CreateSink, mux, decoder, encoder, errhandler, formatter),
		GetSink:               NewGetSinkHandler(e.GetSink, mux, decoder, encoder, errhandler, formatter),
		GetSinkSettings:       NewGetSinkSettingsHandler(e.GetSinkSettings, mux, decoder, encoder, errhandler, formatter),
		UpdateSinkSettings:    NewUpdateSinkSettingsHandler(e.UpdateSinkSettings, mux, decoder, encoder, errhandler, formatter),
		ListSinks:             NewListSinksHandler(e.ListSinks, mux, decoder, encoder, errhandler, formatter),
		UpdateSink:            NewUpdateSinkHandler(e.UpdateSink, mux, decoder, encoder, errhandler, formatter),
		DeleteSink:            NewDeleteSinkHandler(e.DeleteSink, mux, decoder, encoder, errhandler, formatter),
		SinkStatisticsTotal:   NewSinkStatisticsTotalHandler(e.SinkStatisticsTotal, mux, decoder, encoder, errhandler, formatter),
		SinkStatisticsFiles:   NewSinkStatisticsFilesHandler(e.SinkStatisticsFiles, mux, decoder, encoder, errhandler, formatter),
		SinkStatisticsClear:   NewSinkStatisticsClearHandler(e.SinkStatisticsClear, mux, decoder, encoder, errhandler, formatter),
		DisableSink:           NewDisableSinkHandler(e.DisableSink, mux, decoder, encoder, errhandler, formatter),
		EnableSink:            NewEnableSinkHandler(e.EnableSink, mux, decoder, encoder, errhandler, formatter),
		ListSinkVersions:      NewListSinkVersionsHandler(e.ListSinkVersions, mux, decoder, encoder, errhandler, formatter),
		SinkVersionDetail:     NewSinkVersionDetailHandler(e.SinkVersionDetail, mux, decoder, encoder, errhandler, formatter),
		GetTask:               NewGetTaskHandler(e.GetTask, mux, decoder, encoder, errhandler, formatter),
		AggregationSources:    NewAggregationSourcesHandler(e.AggregationSources, mux, decoder, encoder, errhandler, formatter),
		CORS:                  NewCORSHandler(),
		OpenapiJSON:           http.FileServer(fileSystemOpenapiJSON),
		OpenapiYaml:           http.FileServer(fileSystemOpenapiYaml),
		Openapi3JSON:          http.FileServer(fileSystemOpenapi3JSON),
		Openapi3Yaml:          http.FileServer(fileSystemOpenapi3Yaml),
		SwaggerUI:             http.FileServer(fileSystemSwaggerUI),
	}
}

// Service returns the name of the service served.
func (s *Server) Service() string { return "stream" }

// Use wraps the server handlers with the given middleware.
func (s *Server) Use(m func(http.Handler) http.Handler) {
	s.APIRootIndex = m(s.APIRootIndex)
	s.APIVersionIndex = m(s.APIVersionIndex)
	s.HealthCheck = m(s.HealthCheck)
	s.CreateSource = m(s.CreateSource)
	s.UpdateSource = m(s.UpdateSource)
	s.ListSources = m(s.ListSources)
	s.GetSource = m(s.GetSource)
	s.DeleteSource = m(s.DeleteSource)
	s.GetSourceSettings = m(s.GetSourceSettings)
	s.UpdateSourceSettings = m(s.UpdateSourceSettings)
	s.TestSource = m(s.TestSource)
	s.SourceStatisticsClear = m(s.SourceStatisticsClear)
	s.DisableSource = m(s.DisableSource)
	s.EnableSource = m(s.EnableSource)
	s.ListSourceVersions = m(s.ListSourceVersions)
	s.SourceVersionDetail = m(s.SourceVersionDetail)
	s.RollbackSourceVersion = m(s.RollbackSourceVersion)
	s.CreateSink = m(s.CreateSink)
	s.GetSink = m(s.GetSink)
	s.GetSinkSettings = m(s.GetSinkSettings)
	s.UpdateSinkSettings = m(s.UpdateSinkSettings)
	s.ListSinks = m(s.ListSinks)
	s.UpdateSink = m(s.UpdateSink)
	s.DeleteSink = m(s.DeleteSink)
	s.SinkStatisticsTotal = m(s.SinkStatisticsTotal)
	s.SinkStatisticsFiles = m(s.SinkStatisticsFiles)
	s.SinkStatisticsClear = m(s.SinkStatisticsClear)
	s.DisableSink = m(s.DisableSink)
	s.EnableSink = m(s.EnableSink)
	s.ListSinkVersions = m(s.ListSinkVersions)
	s.SinkVersionDetail = m(s.SinkVersionDetail)
	s.GetTask = m(s.GetTask)
	s.AggregationSources = m(s.AggregationSources)
	s.CORS = m(s.CORS)
}

// MethodNames returns the methods served.
func (s *Server) MethodNames() []string { return stream.MethodNames[:] }

// Mount configures the mux to serve the stream endpoints.
func Mount(mux goahttp.Muxer, h *Server) {
	MountAPIRootIndexHandler(mux, h.APIRootIndex)
	MountAPIVersionIndexHandler(mux, h.APIVersionIndex)
	MountHealthCheckHandler(mux, h.HealthCheck)
	MountCreateSourceHandler(mux, h.CreateSource)
	MountUpdateSourceHandler(mux, h.UpdateSource)
	MountListSourcesHandler(mux, h.ListSources)
	MountGetSourceHandler(mux, h.GetSource)
	MountDeleteSourceHandler(mux, h.DeleteSource)
	MountGetSourceSettingsHandler(mux, h.GetSourceSettings)
	MountUpdateSourceSettingsHandler(mux, h.UpdateSourceSettings)
	MountTestSourceHandler(mux, h.TestSource)
	MountSourceStatisticsClearHandler(mux, h.SourceStatisticsClear)
	MountDisableSourceHandler(mux, h.DisableSource)
	MountEnableSourceHandler(mux, h.EnableSource)
	MountListSourceVersionsHandler(mux, h.ListSourceVersions)
	MountSourceVersionDetailHandler(mux, h.SourceVersionDetail)
	MountRollbackSourceVersionHandler(mux, h.RollbackSourceVersion)
	MountCreateSinkHandler(mux, h.CreateSink)
	MountGetSinkHandler(mux, h.GetSink)
	MountGetSinkSettingsHandler(mux, h.GetSinkSettings)
	MountUpdateSinkSettingsHandler(mux, h.UpdateSinkSettings)
	MountListSinksHandler(mux, h.ListSinks)
	MountUpdateSinkHandler(mux, h.UpdateSink)
	MountDeleteSinkHandler(mux, h.DeleteSink)
	MountSinkStatisticsTotalHandler(mux, h.SinkStatisticsTotal)
	MountSinkStatisticsFilesHandler(mux, h.SinkStatisticsFiles)
	MountSinkStatisticsClearHandler(mux, h.SinkStatisticsClear)
	MountDisableSinkHandler(mux, h.DisableSink)
	MountEnableSinkHandler(mux, h.EnableSink)
	MountListSinkVersionsHandler(mux, h.ListSinkVersions)
	MountSinkVersionDetailHandler(mux, h.SinkVersionDetail)
	MountGetTaskHandler(mux, h.GetTask)
	MountAggregationSourcesHandler(mux, h.AggregationSources)
	MountCORSHandler(mux, h.CORS)
	MountOpenapiJSON(mux, http.StripPrefix("/v1/documentation", h.OpenapiJSON))
	MountOpenapiYaml(mux, http.StripPrefix("/v1/documentation", h.OpenapiYaml))
	MountOpenapi3JSON(mux, http.StripPrefix("/v1/documentation", h.Openapi3JSON))
	MountOpenapi3Yaml(mux, http.StripPrefix("/v1/documentation", h.Openapi3Yaml))
	MountSwaggerUI(mux, http.StripPrefix("/v1/documentation", h.SwaggerUI))
}

// Mount configures the mux to serve the stream endpoints.
func (s *Server) Mount(mux goahttp.Muxer) {
	Mount(mux, s)
}

// MountAPIRootIndexHandler configures the mux to serve the "stream" service
// "ApiRootIndex" endpoint.
func MountAPIRootIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/", f)
}

// NewAPIRootIndexHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "ApiRootIndex" endpoint.
func NewAPIRootIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ApiRootIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		http.Redirect(w, r, "/v1", http.StatusMovedPermanently)
	})
}

// MountAPIVersionIndexHandler configures the mux to serve the "stream" service
// "ApiVersionIndex" endpoint.
func MountAPIVersionIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1", f)
}

// NewAPIVersionIndexHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "ApiVersionIndex" endpoint.
func NewAPIVersionIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		encodeResponse = EncodeAPIVersionIndexResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ApiVersionIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		var err error
		res, err := endpoint(ctx, nil)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountHealthCheckHandler configures the mux to serve the "stream" service
// "HealthCheck" endpoint.
func MountHealthCheckHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/health-check", f)
}

// NewHealthCheckHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "HealthCheck" endpoint.
func NewHealthCheckHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		encodeResponse = EncodeHealthCheckResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "HealthCheck")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		var err error
		res, err := endpoint(ctx, nil)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreateSourceHandler configures the mux to serve the "stream" service
// "CreateSource" endpoint.
func MountCreateSourceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/branches/{branchId}/sources", f)
}

// NewCreateSourceHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "CreateSource" endpoint.
func NewCreateSourceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateSourceRequest(mux, decoder)
		encodeResponse = EncodeCreateSourceResponse(encoder)
		encodeError    = EncodeCreateSourceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateSource")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateSourceHandler configures the mux to serve the "stream" service
// "UpdateSource" endpoint.
func MountUpdateSourceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/v1/branches/{branchId}/sources/{sourceId}", f)
}

// NewUpdateSourceHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "UpdateSource" endpoint.
func NewUpdateSourceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateSourceRequest(mux, decoder)
		encodeResponse = EncodeUpdateSourceResponse(encoder)
		encodeError    = EncodeUpdateSourceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateSource")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListSourcesHandler configures the mux to serve the "stream" service
// "ListSources" endpoint.
func MountListSourcesHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources", f)
}

// NewListSourcesHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "ListSources" endpoint.
func NewListSourcesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListSourcesRequest(mux, decoder)
		encodeResponse = EncodeListSourcesResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListSources")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetSourceHandler configures the mux to serve the "stream" service
// "GetSource" endpoint.
func MountGetSourceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}", f)
}

// NewGetSourceHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "GetSource" endpoint.
func NewGetSourceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetSourceRequest(mux, decoder)
		encodeResponse = EncodeGetSourceResponse(encoder)
		encodeError    = EncodeGetSourceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetSource")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteSourceHandler configures the mux to serve the "stream" service
// "DeleteSource" endpoint.
func MountDeleteSourceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/v1/branches/{branchId}/sources/{sourceId}", f)
}

// NewDeleteSourceHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "DeleteSource" endpoint.
func NewDeleteSourceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteSourceRequest(mux, decoder)
		encodeResponse = EncodeDeleteSourceResponse(encoder)
		encodeError    = EncodeDeleteSourceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteSource")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetSourceSettingsHandler configures the mux to serve the "stream"
// service "GetSourceSettings" endpoint.
func MountGetSourceSettingsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/settings", f)
}

// NewGetSourceSettingsHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "GetSourceSettings" endpoint.
func NewGetSourceSettingsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetSourceSettingsRequest(mux, decoder)
		encodeResponse = EncodeGetSourceSettingsResponse(encoder)
		encodeError    = EncodeGetSourceSettingsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetSourceSettings")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateSourceSettingsHandler configures the mux to serve the "stream"
// service "UpdateSourceSettings" endpoint.
func MountUpdateSourceSettingsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/v1/branches/{branchId}/sources/{sourceId}/settings", f)
}

// NewUpdateSourceSettingsHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "UpdateSourceSettings" endpoint.
func NewUpdateSourceSettingsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateSourceSettingsRequest(mux, decoder)
		encodeResponse = EncodeUpdateSourceSettingsResponse(encoder)
		encodeError    = EncodeUpdateSourceSettingsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateSourceSettings")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountTestSourceHandler configures the mux to serve the "stream" service
// "TestSource" endpoint.
func MountTestSourceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/branches/{branchId}/sources/{sourceId}/test", f)
}

// NewTestSourceHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "TestSource" endpoint.
func NewTestSourceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeTestSourceRequest(mux, decoder)
		encodeResponse = EncodeTestSourceResponse(encoder)
		encodeError    = EncodeTestSourceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "TestSource")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		data := &stream.TestSourceRequestData{Payload: payload.(*stream.TestSourcePayload), Body: r.Body}
		res, err := endpoint(ctx, data)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountSourceStatisticsClearHandler configures the mux to serve the "stream"
// service "SourceStatisticsClear" endpoint.
func MountSourceStatisticsClearHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/v1/branches/{branchId}/sources/{sourceId}/statistics/clear", f)
}

// NewSourceStatisticsClearHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "SourceStatisticsClear" endpoint.
func NewSourceStatisticsClearHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeSourceStatisticsClearRequest(mux, decoder)
		encodeResponse = EncodeSourceStatisticsClearResponse(encoder)
		encodeError    = EncodeSourceStatisticsClearError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "SourceStatisticsClear")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDisableSourceHandler configures the mux to serve the "stream" service
// "DisableSource" endpoint.
func MountDisableSourceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PUT", "/v1/branches/{branchId}/sources/{sourceId}/disable", f)
}

// NewDisableSourceHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "DisableSource" endpoint.
func NewDisableSourceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDisableSourceRequest(mux, decoder)
		encodeResponse = EncodeDisableSourceResponse(encoder)
		encodeError    = EncodeDisableSourceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DisableSource")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountEnableSourceHandler configures the mux to serve the "stream" service
// "EnableSource" endpoint.
func MountEnableSourceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PUT", "/v1/branches/{branchId}/sources/{sourceId}/enable", f)
}

// NewEnableSourceHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "EnableSource" endpoint.
func NewEnableSourceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeEnableSourceRequest(mux, decoder)
		encodeResponse = EncodeEnableSourceResponse(encoder)
		encodeError    = EncodeEnableSourceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "EnableSource")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListSourceVersionsHandler configures the mux to serve the "stream"
// service "ListSourceVersions" endpoint.
func MountListSourceVersionsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/versions", f)
}

// NewListSourceVersionsHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "ListSourceVersions" endpoint.
func NewListSourceVersionsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListSourceVersionsRequest(mux, decoder)
		encodeResponse = EncodeListSourceVersionsResponse(encoder)
		encodeError    = EncodeListSourceVersionsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListSourceVersions")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountSourceVersionDetailHandler configures the mux to serve the "stream"
// service "SourceVersionDetail" endpoint.
func MountSourceVersionDetailHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/versions/{versionNumber}", f)
}

// NewSourceVersionDetailHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "SourceVersionDetail" endpoint.
func NewSourceVersionDetailHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeSourceVersionDetailRequest(mux, decoder)
		encodeResponse = EncodeSourceVersionDetailResponse(encoder)
		encodeError    = EncodeSourceVersionDetailError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "SourceVersionDetail")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountRollbackSourceVersionHandler configures the mux to serve the "stream"
// service "RollbackSourceVersion" endpoint.
func MountRollbackSourceVersionHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PUT", "/v1/branches/{branchId}/sources/{sourceId}/versions/{versionNumber}/rollback", f)
}

// NewRollbackSourceVersionHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "RollbackSourceVersion" endpoint.
func NewRollbackSourceVersionHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeRollbackSourceVersionRequest(mux, decoder)
		encodeResponse = EncodeRollbackSourceVersionResponse(encoder)
		encodeError    = EncodeRollbackSourceVersionError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "RollbackSourceVersion")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreateSinkHandler configures the mux to serve the "stream" service
// "CreateSink" endpoint.
func MountCreateSinkHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/branches/{branchId}/sources/{sourceId}/sinks", f)
}

// NewCreateSinkHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "CreateSink" endpoint.
func NewCreateSinkHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateSinkRequest(mux, decoder)
		encodeResponse = EncodeCreateSinkResponse(encoder)
		encodeError    = EncodeCreateSinkError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateSink")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetSinkHandler configures the mux to serve the "stream" service
// "GetSink" endpoint.
func MountGetSinkHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}", f)
}

// NewGetSinkHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "GetSink" endpoint.
func NewGetSinkHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetSinkRequest(mux, decoder)
		encodeResponse = EncodeGetSinkResponse(encoder)
		encodeError    = EncodeGetSinkError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetSink")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetSinkSettingsHandler configures the mux to serve the "stream" service
// "GetSinkSettings" endpoint.
func MountGetSinkSettingsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/settings", f)
}

// NewGetSinkSettingsHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "GetSinkSettings" endpoint.
func NewGetSinkSettingsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetSinkSettingsRequest(mux, decoder)
		encodeResponse = EncodeGetSinkSettingsResponse(encoder)
		encodeError    = EncodeGetSinkSettingsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetSinkSettings")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateSinkSettingsHandler configures the mux to serve the "stream"
// service "UpdateSinkSettings" endpoint.
func MountUpdateSinkSettingsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/settings", f)
}

// NewUpdateSinkSettingsHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "UpdateSinkSettings" endpoint.
func NewUpdateSinkSettingsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateSinkSettingsRequest(mux, decoder)
		encodeResponse = EncodeUpdateSinkSettingsResponse(encoder)
		encodeError    = EncodeUpdateSinkSettingsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateSinkSettings")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListSinksHandler configures the mux to serve the "stream" service
// "ListSinks" endpoint.
func MountListSinksHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks", f)
}

// NewListSinksHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "ListSinks" endpoint.
func NewListSinksHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListSinksRequest(mux, decoder)
		encodeResponse = EncodeListSinksResponse(encoder)
		encodeError    = EncodeListSinksError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListSinks")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateSinkHandler configures the mux to serve the "stream" service
// "UpdateSink" endpoint.
func MountUpdateSinkHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}", f)
}

// NewUpdateSinkHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "UpdateSink" endpoint.
func NewUpdateSinkHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateSinkRequest(mux, decoder)
		encodeResponse = EncodeUpdateSinkResponse(encoder)
		encodeError    = EncodeUpdateSinkError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateSink")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteSinkHandler configures the mux to serve the "stream" service
// "DeleteSink" endpoint.
func MountDeleteSinkHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}", f)
}

// NewDeleteSinkHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "DeleteSink" endpoint.
func NewDeleteSinkHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteSinkRequest(mux, decoder)
		encodeResponse = EncodeDeleteSinkResponse(encoder)
		encodeError    = EncodeDeleteSinkError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteSink")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountSinkStatisticsTotalHandler configures the mux to serve the "stream"
// service "SinkStatisticsTotal" endpoint.
func MountSinkStatisticsTotalHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/total", f)
}

// NewSinkStatisticsTotalHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "SinkStatisticsTotal" endpoint.
func NewSinkStatisticsTotalHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeSinkStatisticsTotalRequest(mux, decoder)
		encodeResponse = EncodeSinkStatisticsTotalResponse(encoder)
		encodeError    = EncodeSinkStatisticsTotalError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "SinkStatisticsTotal")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountSinkStatisticsFilesHandler configures the mux to serve the "stream"
// service "SinkStatisticsFiles" endpoint.
func MountSinkStatisticsFilesHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/files", f)
}

// NewSinkStatisticsFilesHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "SinkStatisticsFiles" endpoint.
func NewSinkStatisticsFilesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeSinkStatisticsFilesRequest(mux, decoder)
		encodeResponse = EncodeSinkStatisticsFilesResponse(encoder)
		encodeError    = EncodeSinkStatisticsFilesError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "SinkStatisticsFiles")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountSinkStatisticsClearHandler configures the mux to serve the "stream"
// service "SinkStatisticsClear" endpoint.
func MountSinkStatisticsClearHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/clear", f)
}

// NewSinkStatisticsClearHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "SinkStatisticsClear" endpoint.
func NewSinkStatisticsClearHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeSinkStatisticsClearRequest(mux, decoder)
		encodeResponse = EncodeSinkStatisticsClearResponse(encoder)
		encodeError    = EncodeSinkStatisticsClearError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "SinkStatisticsClear")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDisableSinkHandler configures the mux to serve the "stream" service
// "DisableSink" endpoint.
func MountDisableSinkHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PUT", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/disable", f)
}

// NewDisableSinkHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "DisableSink" endpoint.
func NewDisableSinkHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDisableSinkRequest(mux, decoder)
		encodeResponse = EncodeDisableSinkResponse(encoder)
		encodeError    = EncodeDisableSinkError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DisableSink")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountEnableSinkHandler configures the mux to serve the "stream" service
// "EnableSink" endpoint.
func MountEnableSinkHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PUT", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/enable", f)
}

// NewEnableSinkHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "EnableSink" endpoint.
func NewEnableSinkHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeEnableSinkRequest(mux, decoder)
		encodeResponse = EncodeEnableSinkResponse(encoder)
		encodeError    = EncodeEnableSinkError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "EnableSink")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListSinkVersionsHandler configures the mux to serve the "stream"
// service "ListSinkVersions" endpoint.
func MountListSinkVersionsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/versions", f)
}

// NewListSinkVersionsHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "ListSinkVersions" endpoint.
func NewListSinkVersionsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListSinkVersionsRequest(mux, decoder)
		encodeResponse = EncodeListSinkVersionsResponse(encoder)
		encodeError    = EncodeListSinkVersionsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListSinkVersions")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountSinkVersionDetailHandler configures the mux to serve the "stream"
// service "SinkVersionDetail" endpoint.
func MountSinkVersionDetailHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/versions/{versionNumber}", f)
}

// NewSinkVersionDetailHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "SinkVersionDetail" endpoint.
func NewSinkVersionDetailHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeSinkVersionDetailRequest(mux, decoder)
		encodeResponse = EncodeSinkVersionDetailResponse(encoder)
		encodeError    = EncodeSinkVersionDetailError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "SinkVersionDetail")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetTaskHandler configures the mux to serve the "stream" service
// "GetTask" endpoint.
func MountGetTaskHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/tasks/{*taskId}", f)
}

// NewGetTaskHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "GetTask" endpoint.
func NewGetTaskHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetTaskRequest(mux, decoder)
		encodeResponse = EncodeGetTaskResponse(encoder)
		encodeError    = EncodeGetTaskError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetTask")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountAggregationSourcesHandler configures the mux to serve the "stream"
// service "AggregationSources" endpoint.
func MountAggregationSourcesHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/aggregation/sources", f)
}

// NewAggregationSourcesHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "AggregationSources" endpoint.
func NewAggregationSourcesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeAggregationSourcesRequest(mux, decoder)
		encodeResponse = EncodeAggregationSourcesResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "AggregationSources")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// appendFS is a custom implementation of fs.FS that appends a specified prefix
// to the file paths before delegating the Open call to the underlying fs.FS.
type appendFS struct {
	prefix string
	fs     http.FileSystem
}

// Open opens the named file, appending the prefix to the file path before
// passing it to the underlying fs.FS.
func (s appendFS) Open(name string) (http.File, error) {
	switch name {
	}
	return s.fs.Open(path.Join(s.prefix, name))
}

// appendPrefix returns a new fs.FS that appends the specified prefix to file paths
// before delegating to the provided embed.FS.
func appendPrefix(fsys http.FileSystem, prefix string) http.FileSystem {
	return appendFS{prefix: prefix, fs: fsys}
}

// MountOpenapiJSON configures the mux to serve GET request made to
// "/v1/documentation/openapi.json".
func MountOpenapiJSON(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi.json", HandleStreamOrigin(h).ServeHTTP)
}

// MountOpenapiYaml configures the mux to serve GET request made to
// "/v1/documentation/openapi.yaml".
func MountOpenapiYaml(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi.yaml", HandleStreamOrigin(h).ServeHTTP)
}

// MountOpenapi3JSON configures the mux to serve GET request made to
// "/v1/documentation/openapi3.json".
func MountOpenapi3JSON(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi3.json", HandleStreamOrigin(h).ServeHTTP)
}

// MountOpenapi3Yaml configures the mux to serve GET request made to
// "/v1/documentation/openapi3.yaml".
func MountOpenapi3Yaml(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi3.yaml", HandleStreamOrigin(h).ServeHTTP)
}

// MountSwaggerUI configures the mux to serve GET request made to
// "/v1/documentation".
func MountSwaggerUI(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/", HandleStreamOrigin(h).ServeHTTP)
	mux.Handle("GET", "/v1/documentation/{*path}", HandleStreamOrigin(h).ServeHTTP)
}

// MountCORSHandler configures the mux to serve the CORS endpoints for the
// service stream.
func MountCORSHandler(mux goahttp.Muxer, h http.Handler) {
	h = HandleStreamOrigin(h)
	mux.Handle("OPTIONS", "/", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1", h.ServeHTTP)
	mux.Handle("OPTIONS", "/health-check", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/settings", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/test", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/statistics/clear", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/disable", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/enable", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/versions", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/versions/{versionNumber}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/versions/{versionNumber}/rollback", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/settings", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/total", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/files", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/clear", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/disable", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/enable", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/versions", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/versions/{versionNumber}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/tasks/{*taskId}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/aggregation/sources", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi.json", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi.yaml", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi3.json", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi3.yaml", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/{*path}", h.ServeHTTP)
}

// NewCORSHandler creates a HTTP handler which returns a simple 204 response.
func NewCORSHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(204)
	})
}

// HandleStreamOrigin applies the CORS response headers corresponding to the
// origin for the service stream.
func HandleStreamOrigin(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		origin := r.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			h.ServeHTTP(w, r)
			return
		}
		if cors.MatchOrigin(origin, "*") {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PATCH, DELETE")
				w.Header().Set("Access-Control-Allow-Headers", "Content-Type, X-StorageApi-Token")
				w.WriteHeader(204)
				return
			}
			h.ServeHTTP(w, r)
			return
		}
		h.ServeHTTP(w, r)
		return
	})
}
