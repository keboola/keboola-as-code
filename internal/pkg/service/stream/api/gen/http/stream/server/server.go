// Code generated by goa v3.16.2, DO NOT EDIT.
//
// stream HTTP server
//
// Command:
// $ goa gen github.com/keboola/keboola-as-code/api/stream --output
// ./internal/pkg/service/stream/api

package server

import (
	"context"
	"net/http"

	stream "github.com/keboola/keboola-as-code/internal/pkg/service/stream/api/gen/stream"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
	"goa.design/plugins/v3/cors"
)

// Server lists the stream service endpoint HTTP handlers.
type Server struct {
	Mounts               []*MountPoint
	APIRootIndex         http.Handler
	APIVersionIndex      http.Handler
	HealthCheck          http.Handler
	CreateSource         http.Handler
	UpdateSource         http.Handler
	ListSources          http.Handler
	GetSource            http.Handler
	DeleteSource         http.Handler
	GetSourceSettings    http.Handler
	UpdateSourceSettings http.Handler
	TestSource           http.Handler
	CreateSink           http.Handler
	GetSink              http.Handler
	GetSinkSettings      http.Handler
	UpdateSinkSettings   http.Handler
	ListSinks            http.Handler
	UpdateSink           http.Handler
	DeleteSink           http.Handler
	SinkStatisticsTotal  http.Handler
	SinkStatisticsFiles  http.Handler
	GetTask              http.Handler
	CORS                 http.Handler
	OpenapiJSON          http.Handler
	OpenapiYaml          http.Handler
	Openapi3JSON         http.Handler
	Openapi3Yaml         http.Handler
	SwaggerUI            http.Handler
}

// MountPoint holds information about the mounted endpoints.
type MountPoint struct {
	// Method is the name of the service method served by the mounted HTTP handler.
	Method string
	// Verb is the HTTP method used to match requests to the mounted handler.
	Verb string
	// Pattern is the HTTP request path pattern used to match requests to the
	// mounted handler.
	Pattern string
}

// New instantiates HTTP handlers for all the stream service endpoints using
// the provided encoder and decoder. The handlers are mounted on the given mux
// using the HTTP verb and path defined in the design. errhandler is called
// whenever a response fails to be encoded. formatter is used to format errors
// returned by the service methods prior to encoding. Both errhandler and
// formatter are optional and can be nil.
func New(
	e *stream.Endpoints,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
	fileSystemOpenapiJSON http.FileSystem,
	fileSystemOpenapiYaml http.FileSystem,
	fileSystemOpenapi3JSON http.FileSystem,
	fileSystemOpenapi3Yaml http.FileSystem,
	fileSystemSwaggerUI http.FileSystem,
) *Server {
	if fileSystemOpenapiJSON == nil {
		fileSystemOpenapiJSON = http.Dir(".")
	}
	if fileSystemOpenapiYaml == nil {
		fileSystemOpenapiYaml = http.Dir(".")
	}
	if fileSystemOpenapi3JSON == nil {
		fileSystemOpenapi3JSON = http.Dir(".")
	}
	if fileSystemOpenapi3Yaml == nil {
		fileSystemOpenapi3Yaml = http.Dir(".")
	}
	if fileSystemSwaggerUI == nil {
		fileSystemSwaggerUI = http.Dir(".")
	}
	return &Server{
		Mounts: []*MountPoint{
			{"APIRootIndex", "GET", "/"},
			{"APIVersionIndex", "GET", "/v1"},
			{"HealthCheck", "GET", "/health-check"},
			{"CreateSource", "POST", "/v1/branches/{branchId}/sources"},
			{"UpdateSource", "PATCH", "/v1/branches/{branchId}/sources/{sourceId}"},
			{"ListSources", "GET", "/v1/branches/{branchId}/sources"},
			{"GetSource", "GET", "/v1/branches/{branchId}/sources/{sourceId}"},
			{"DeleteSource", "DELETE", "/v1/branches/{branchId}/sources/{sourceId}"},
			{"GetSourceSettings", "GET", "/v1/branches/{branchId}/sources/{sourceId}/settings"},
			{"UpdateSourceSettings", "PATCH", "/v1/branches/{branchId}/sources/{sourceId}/settings"},
			{"TestSource", "POST", "/v1/branches/{branchId}/sources/{sourceId}/test"},
			{"CreateSink", "POST", "/v1/branches/{branchId}/sources/{sourceId}/sinks"},
			{"GetSink", "GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}"},
			{"GetSinkSettings", "GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/settings"},
			{"UpdateSinkSettings", "PATCH", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/settings"},
			{"ListSinks", "GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks"},
			{"UpdateSink", "PATCH", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}"},
			{"DeleteSink", "DELETE", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}"},
			{"SinkStatisticsTotal", "GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/total"},
			{"SinkStatisticsFiles", "GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/files"},
			{"GetTask", "GET", "/v1/tasks/{*taskId}"},
			{"CORS", "OPTIONS", "/"},
			{"CORS", "OPTIONS", "/v1"},
			{"CORS", "OPTIONS", "/health-check"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/settings"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/test"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/settings"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/total"},
			{"CORS", "OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/files"},
			{"CORS", "OPTIONS", "/v1/tasks/{*taskId}"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi.json"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi.yaml"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi3.json"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi3.yaml"},
			{"CORS", "OPTIONS", "/v1/documentation/{*path}"},
			{"openapi.json", "GET", "/v1/documentation/openapi.json"},
			{"openapi.yaml", "GET", "/v1/documentation/openapi.yaml"},
			{"openapi3.json", "GET", "/v1/documentation/openapi3.json"},
			{"openapi3.yaml", "GET", "/v1/documentation/openapi3.yaml"},
			{"swagger-ui", "GET", "/v1/documentation"},
		},
		APIRootIndex:         NewAPIRootIndexHandler(e.APIRootIndex, mux, decoder, encoder, errhandler, formatter),
		APIVersionIndex:      NewAPIVersionIndexHandler(e.APIVersionIndex, mux, decoder, encoder, errhandler, formatter),
		HealthCheck:          NewHealthCheckHandler(e.HealthCheck, mux, decoder, encoder, errhandler, formatter),
		CreateSource:         NewCreateSourceHandler(e.CreateSource, mux, decoder, encoder, errhandler, formatter),
		UpdateSource:         NewUpdateSourceHandler(e.UpdateSource, mux, decoder, encoder, errhandler, formatter),
		ListSources:          NewListSourcesHandler(e.ListSources, mux, decoder, encoder, errhandler, formatter),
		GetSource:            NewGetSourceHandler(e.GetSource, mux, decoder, encoder, errhandler, formatter),
		DeleteSource:         NewDeleteSourceHandler(e.DeleteSource, mux, decoder, encoder, errhandler, formatter),
		GetSourceSettings:    NewGetSourceSettingsHandler(e.GetSourceSettings, mux, decoder, encoder, errhandler, formatter),
		UpdateSourceSettings: NewUpdateSourceSettingsHandler(e.UpdateSourceSettings, mux, decoder, encoder, errhandler, formatter),
		TestSource:           NewTestSourceHandler(e.TestSource, mux, decoder, encoder, errhandler, formatter),
		CreateSink:           NewCreateSinkHandler(e.CreateSink, mux, decoder, encoder, errhandler, formatter),
		GetSink:              NewGetSinkHandler(e.GetSink, mux, decoder, encoder, errhandler, formatter),
		GetSinkSettings:      NewGetSinkSettingsHandler(e.GetSinkSettings, mux, decoder, encoder, errhandler, formatter),
		UpdateSinkSettings:   NewUpdateSinkSettingsHandler(e.UpdateSinkSettings, mux, decoder, encoder, errhandler, formatter),
		ListSinks:            NewListSinksHandler(e.ListSinks, mux, decoder, encoder, errhandler, formatter),
		UpdateSink:           NewUpdateSinkHandler(e.UpdateSink, mux, decoder, encoder, errhandler, formatter),
		DeleteSink:           NewDeleteSinkHandler(e.DeleteSink, mux, decoder, encoder, errhandler, formatter),
		SinkStatisticsTotal:  NewSinkStatisticsTotalHandler(e.SinkStatisticsTotal, mux, decoder, encoder, errhandler, formatter),
		SinkStatisticsFiles:  NewSinkStatisticsFilesHandler(e.SinkStatisticsFiles, mux, decoder, encoder, errhandler, formatter),
		GetTask:              NewGetTaskHandler(e.GetTask, mux, decoder, encoder, errhandler, formatter),
		CORS:                 NewCORSHandler(),
		OpenapiJSON:          http.FileServer(fileSystemOpenapiJSON),
		OpenapiYaml:          http.FileServer(fileSystemOpenapiYaml),
		Openapi3JSON:         http.FileServer(fileSystemOpenapi3JSON),
		Openapi3Yaml:         http.FileServer(fileSystemOpenapi3Yaml),
		SwaggerUI:            http.FileServer(fileSystemSwaggerUI),
	}
}

// Service returns the name of the service served.
func (s *Server) Service() string { return "stream" }

// Use wraps the server handlers with the given middleware.
func (s *Server) Use(m func(http.Handler) http.Handler) {
	s.APIRootIndex = m(s.APIRootIndex)
	s.APIVersionIndex = m(s.APIVersionIndex)
	s.HealthCheck = m(s.HealthCheck)
	s.CreateSource = m(s.CreateSource)
	s.UpdateSource = m(s.UpdateSource)
	s.ListSources = m(s.ListSources)
	s.GetSource = m(s.GetSource)
	s.DeleteSource = m(s.DeleteSource)
	s.GetSourceSettings = m(s.GetSourceSettings)
	s.UpdateSourceSettings = m(s.UpdateSourceSettings)
	s.TestSource = m(s.TestSource)
	s.CreateSink = m(s.CreateSink)
	s.GetSink = m(s.GetSink)
	s.GetSinkSettings = m(s.GetSinkSettings)
	s.UpdateSinkSettings = m(s.UpdateSinkSettings)
	s.ListSinks = m(s.ListSinks)
	s.UpdateSink = m(s.UpdateSink)
	s.DeleteSink = m(s.DeleteSink)
	s.SinkStatisticsTotal = m(s.SinkStatisticsTotal)
	s.SinkStatisticsFiles = m(s.SinkStatisticsFiles)
	s.GetTask = m(s.GetTask)
	s.CORS = m(s.CORS)
}

// MethodNames returns the methods served.
func (s *Server) MethodNames() []string { return stream.MethodNames[:] }

// Mount configures the mux to serve the stream endpoints.
func Mount(mux goahttp.Muxer, h *Server) {
	MountAPIRootIndexHandler(mux, h.APIRootIndex)
	MountAPIVersionIndexHandler(mux, h.APIVersionIndex)
	MountHealthCheckHandler(mux, h.HealthCheck)
	MountCreateSourceHandler(mux, h.CreateSource)
	MountUpdateSourceHandler(mux, h.UpdateSource)
	MountListSourcesHandler(mux, h.ListSources)
	MountGetSourceHandler(mux, h.GetSource)
	MountDeleteSourceHandler(mux, h.DeleteSource)
	MountGetSourceSettingsHandler(mux, h.GetSourceSettings)
	MountUpdateSourceSettingsHandler(mux, h.UpdateSourceSettings)
	MountTestSourceHandler(mux, h.TestSource)
	MountCreateSinkHandler(mux, h.CreateSink)
	MountGetSinkHandler(mux, h.GetSink)
	MountGetSinkSettingsHandler(mux, h.GetSinkSettings)
	MountUpdateSinkSettingsHandler(mux, h.UpdateSinkSettings)
	MountListSinksHandler(mux, h.ListSinks)
	MountUpdateSinkHandler(mux, h.UpdateSink)
	MountDeleteSinkHandler(mux, h.DeleteSink)
	MountSinkStatisticsTotalHandler(mux, h.SinkStatisticsTotal)
	MountSinkStatisticsFilesHandler(mux, h.SinkStatisticsFiles)
	MountGetTaskHandler(mux, h.GetTask)
	MountCORSHandler(mux, h.CORS)
	MountOpenapiJSON(mux, goahttp.Replace("", "/openapi.json", h.OpenapiJSON))
	MountOpenapiYaml(mux, goahttp.Replace("", "/openapi.yaml", h.OpenapiYaml))
	MountOpenapi3JSON(mux, goahttp.Replace("", "/openapi3.json", h.Openapi3JSON))
	MountOpenapi3Yaml(mux, goahttp.Replace("", "/openapi3.yaml", h.Openapi3Yaml))
	MountSwaggerUI(mux, goahttp.Replace("/v1/documentation", "/swagger-ui", h.SwaggerUI))
}

// Mount configures the mux to serve the stream endpoints.
func (s *Server) Mount(mux goahttp.Muxer) {
	Mount(mux, s)
}

// MountAPIRootIndexHandler configures the mux to serve the "stream" service
// "ApiRootIndex" endpoint.
func MountAPIRootIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/", f)
}

// NewAPIRootIndexHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "ApiRootIndex" endpoint.
func NewAPIRootIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ApiRootIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		http.Redirect(w, r, "/v1", http.StatusMovedPermanently)
	})
}

// MountAPIVersionIndexHandler configures the mux to serve the "stream" service
// "ApiVersionIndex" endpoint.
func MountAPIVersionIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1", f)
}

// NewAPIVersionIndexHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "ApiVersionIndex" endpoint.
func NewAPIVersionIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		encodeResponse = EncodeAPIVersionIndexResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ApiVersionIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		var err error
		res, err := endpoint(ctx, nil)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountHealthCheckHandler configures the mux to serve the "stream" service
// "HealthCheck" endpoint.
func MountHealthCheckHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/health-check", f)
}

// NewHealthCheckHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "HealthCheck" endpoint.
func NewHealthCheckHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		encodeResponse = EncodeHealthCheckResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "HealthCheck")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		var err error
		res, err := endpoint(ctx, nil)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreateSourceHandler configures the mux to serve the "stream" service
// "CreateSource" endpoint.
func MountCreateSourceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/branches/{branchId}/sources", f)
}

// NewCreateSourceHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "CreateSource" endpoint.
func NewCreateSourceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateSourceRequest(mux, decoder)
		encodeResponse = EncodeCreateSourceResponse(encoder)
		encodeError    = EncodeCreateSourceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateSource")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateSourceHandler configures the mux to serve the "stream" service
// "UpdateSource" endpoint.
func MountUpdateSourceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/v1/branches/{branchId}/sources/{sourceId}", f)
}

// NewUpdateSourceHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "UpdateSource" endpoint.
func NewUpdateSourceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateSourceRequest(mux, decoder)
		encodeResponse = EncodeUpdateSourceResponse(encoder)
		encodeError    = EncodeUpdateSourceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateSource")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListSourcesHandler configures the mux to serve the "stream" service
// "ListSources" endpoint.
func MountListSourcesHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources", f)
}

// NewListSourcesHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "ListSources" endpoint.
func NewListSourcesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListSourcesRequest(mux, decoder)
		encodeResponse = EncodeListSourcesResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListSources")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetSourceHandler configures the mux to serve the "stream" service
// "GetSource" endpoint.
func MountGetSourceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}", f)
}

// NewGetSourceHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "GetSource" endpoint.
func NewGetSourceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetSourceRequest(mux, decoder)
		encodeResponse = EncodeGetSourceResponse(encoder)
		encodeError    = EncodeGetSourceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetSource")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteSourceHandler configures the mux to serve the "stream" service
// "DeleteSource" endpoint.
func MountDeleteSourceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/v1/branches/{branchId}/sources/{sourceId}", f)
}

// NewDeleteSourceHandler creates a HTTP handler which loads the HTTP request
// and calls the "stream" service "DeleteSource" endpoint.
func NewDeleteSourceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteSourceRequest(mux, decoder)
		encodeResponse = EncodeDeleteSourceResponse(encoder)
		encodeError    = EncodeDeleteSourceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteSource")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetSourceSettingsHandler configures the mux to serve the "stream"
// service "GetSourceSettings" endpoint.
func MountGetSourceSettingsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/settings", f)
}

// NewGetSourceSettingsHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "GetSourceSettings" endpoint.
func NewGetSourceSettingsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetSourceSettingsRequest(mux, decoder)
		encodeResponse = EncodeGetSourceSettingsResponse(encoder)
		encodeError    = EncodeGetSourceSettingsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetSourceSettings")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateSourceSettingsHandler configures the mux to serve the "stream"
// service "UpdateSourceSettings" endpoint.
func MountUpdateSourceSettingsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/v1/branches/{branchId}/sources/{sourceId}/settings", f)
}

// NewUpdateSourceSettingsHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "UpdateSourceSettings" endpoint.
func NewUpdateSourceSettingsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateSourceSettingsRequest(mux, decoder)
		encodeResponse = EncodeUpdateSourceSettingsResponse(encoder)
		encodeError    = EncodeUpdateSourceSettingsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateSourceSettings")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountTestSourceHandler configures the mux to serve the "stream" service
// "TestSource" endpoint.
func MountTestSourceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/branches/{branchId}/sources/{sourceId}/test", f)
}

// NewTestSourceHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "TestSource" endpoint.
func NewTestSourceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeTestSourceRequest(mux, decoder)
		encodeResponse = EncodeTestSourceResponse(encoder)
		encodeError    = EncodeTestSourceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "TestSource")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		data := &stream.TestSourceRequestData{Payload: payload.(*stream.TestSourcePayload), Body: r.Body}
		res, err := endpoint(ctx, data)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreateSinkHandler configures the mux to serve the "stream" service
// "CreateSink" endpoint.
func MountCreateSinkHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/branches/{branchId}/sources/{sourceId}/sinks", f)
}

// NewCreateSinkHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "CreateSink" endpoint.
func NewCreateSinkHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateSinkRequest(mux, decoder)
		encodeResponse = EncodeCreateSinkResponse(encoder)
		encodeError    = EncodeCreateSinkError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateSink")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetSinkHandler configures the mux to serve the "stream" service
// "GetSink" endpoint.
func MountGetSinkHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}", f)
}

// NewGetSinkHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "GetSink" endpoint.
func NewGetSinkHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetSinkRequest(mux, decoder)
		encodeResponse = EncodeGetSinkResponse(encoder)
		encodeError    = EncodeGetSinkError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetSink")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetSinkSettingsHandler configures the mux to serve the "stream" service
// "GetSinkSettings" endpoint.
func MountGetSinkSettingsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/settings", f)
}

// NewGetSinkSettingsHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "GetSinkSettings" endpoint.
func NewGetSinkSettingsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetSinkSettingsRequest(mux, decoder)
		encodeResponse = EncodeGetSinkSettingsResponse(encoder)
		encodeError    = EncodeGetSinkSettingsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetSinkSettings")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateSinkSettingsHandler configures the mux to serve the "stream"
// service "UpdateSinkSettings" endpoint.
func MountUpdateSinkSettingsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/settings", f)
}

// NewUpdateSinkSettingsHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "UpdateSinkSettings" endpoint.
func NewUpdateSinkSettingsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateSinkSettingsRequest(mux, decoder)
		encodeResponse = EncodeUpdateSinkSettingsResponse(encoder)
		encodeError    = EncodeUpdateSinkSettingsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateSinkSettings")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListSinksHandler configures the mux to serve the "stream" service
// "ListSinks" endpoint.
func MountListSinksHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks", f)
}

// NewListSinksHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "ListSinks" endpoint.
func NewListSinksHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListSinksRequest(mux, decoder)
		encodeResponse = EncodeListSinksResponse(encoder)
		encodeError    = EncodeListSinksError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListSinks")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateSinkHandler configures the mux to serve the "stream" service
// "UpdateSink" endpoint.
func MountUpdateSinkHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}", f)
}

// NewUpdateSinkHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "UpdateSink" endpoint.
func NewUpdateSinkHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateSinkRequest(mux, decoder)
		encodeResponse = EncodeUpdateSinkResponse(encoder)
		encodeError    = EncodeUpdateSinkError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateSink")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteSinkHandler configures the mux to serve the "stream" service
// "DeleteSink" endpoint.
func MountDeleteSinkHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}", f)
}

// NewDeleteSinkHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "DeleteSink" endpoint.
func NewDeleteSinkHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteSinkRequest(mux, decoder)
		encodeResponse = EncodeDeleteSinkResponse(encoder)
		encodeError    = EncodeDeleteSinkError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteSink")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountSinkStatisticsTotalHandler configures the mux to serve the "stream"
// service "SinkStatisticsTotal" endpoint.
func MountSinkStatisticsTotalHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/total", f)
}

// NewSinkStatisticsTotalHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "SinkStatisticsTotal" endpoint.
func NewSinkStatisticsTotalHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeSinkStatisticsTotalRequest(mux, decoder)
		encodeResponse = EncodeSinkStatisticsTotalResponse(encoder)
		encodeError    = EncodeSinkStatisticsTotalError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "SinkStatisticsTotal")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountSinkStatisticsFilesHandler configures the mux to serve the "stream"
// service "SinkStatisticsFiles" endpoint.
func MountSinkStatisticsFilesHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/files", f)
}

// NewSinkStatisticsFilesHandler creates a HTTP handler which loads the HTTP
// request and calls the "stream" service "SinkStatisticsFiles" endpoint.
func NewSinkStatisticsFilesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeSinkStatisticsFilesRequest(mux, decoder)
		encodeResponse = EncodeSinkStatisticsFilesResponse(encoder)
		encodeError    = EncodeSinkStatisticsFilesError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "SinkStatisticsFiles")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetTaskHandler configures the mux to serve the "stream" service
// "GetTask" endpoint.
func MountGetTaskHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStreamOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/tasks/{*taskId}", f)
}

// NewGetTaskHandler creates a HTTP handler which loads the HTTP request and
// calls the "stream" service "GetTask" endpoint.
func NewGetTaskHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetTaskRequest(mux, decoder)
		encodeResponse = EncodeGetTaskResponse(encoder)
		encodeError    = EncodeGetTaskError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetTask")
		ctx = context.WithValue(ctx, goa.ServiceKey, "stream")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountOpenapiJSON configures the mux to serve GET request made to
// "/v1/documentation/openapi.json".
func MountOpenapiJSON(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi.json", HandleStreamOrigin(h).ServeHTTP)
}

// MountOpenapiYaml configures the mux to serve GET request made to
// "/v1/documentation/openapi.yaml".
func MountOpenapiYaml(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi.yaml", HandleStreamOrigin(h).ServeHTTP)
}

// MountOpenapi3JSON configures the mux to serve GET request made to
// "/v1/documentation/openapi3.json".
func MountOpenapi3JSON(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi3.json", HandleStreamOrigin(h).ServeHTTP)
}

// MountOpenapi3Yaml configures the mux to serve GET request made to
// "/v1/documentation/openapi3.yaml".
func MountOpenapi3Yaml(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi3.yaml", HandleStreamOrigin(h).ServeHTTP)
}

// MountSwaggerUI configures the mux to serve GET request made to
// "/v1/documentation".
func MountSwaggerUI(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/", HandleStreamOrigin(h).ServeHTTP)
	mux.Handle("GET", "/v1/documentation/{*path}", HandleStreamOrigin(h).ServeHTTP)
}

// MountCORSHandler configures the mux to serve the CORS endpoints for the
// service stream.
func MountCORSHandler(mux goahttp.Muxer, h http.Handler) {
	h = HandleStreamOrigin(h)
	mux.Handle("OPTIONS", "/", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1", h.ServeHTTP)
	mux.Handle("OPTIONS", "/health-check", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/settings", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/test", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/settings", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/total", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/branches/{branchId}/sources/{sourceId}/sinks/{sinkId}/statistics/files", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/tasks/{*taskId}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi.json", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi.yaml", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi3.json", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi3.yaml", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/{*path}", h.ServeHTTP)
}

// NewCORSHandler creates a HTTP handler which returns a simple 204 response.
func NewCORSHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(204)
	})
}

// HandleStreamOrigin applies the CORS response headers corresponding to the
// origin for the service stream.
func HandleStreamOrigin(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		origin := r.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			h.ServeHTTP(w, r)
			return
		}
		if cors.MatchOrigin(origin, "*") {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PATCH, DELETE")
				w.Header().Set("Access-Control-Allow-Headers", "Content-Type, X-StorageApi-Token")
				w.WriteHeader(204)
				return
			}
			h.ServeHTTP(w, r)
			return
		}
		h.ServeHTTP(w, r)
		return
	})
}
