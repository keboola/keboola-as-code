package config

import (
	"net/url"
	"time"

	"github.com/keboola/keboola-as-code/internal/pkg/env"
	"github.com/keboola/keboola-as-code/internal/pkg/model"
	"github.com/keboola/keboola-as-code/internal/pkg/service/common/configmap"
	"github.com/keboola/keboola-as-code/internal/pkg/service/common/etcdclient"
	"github.com/keboola/keboola-as-code/internal/pkg/utils/errors"
	"github.com/keboola/keboola-as-code/internal/pkg/utils/strhelper"
	"github.com/keboola/keboola-as-code/internal/pkg/validator"
)

const (
	EnvPrefix              = "TEMPLATES_API_"
	DefaultCleanupInterval = 1 * time.Hour
)

// Config of the Templates API.
// See "configmap" package for more information.
type Config struct {
	DebugLog             bool                   `mapstructure:"debug-log" usage:"Enable debug log level."`
	DebugEtcd            bool                   `mapstructure:"debug-etcd" usage:"Enable logging of each etcd KV operation as a debug message."`
	DebugHTTP            bool                   `mapstructure:"debug-http" usage:"Log HTTP client request and response bodies."`
	DatadogEnabled       bool                   `mapstructure:"datadog-enabled" usage:"Enable Datadog telemetry integration."`
	DatadogDebug         bool                   `mapstructure:"datadog-debug" usage:"Enable Datadog debug logs."`
	CpuProfFilePath      string                 `mapstructure:"cpu-profile" usage:"Write cpu profile to the file."`
	ListenAddress        string                 `mapstructure:"listen-address" usage:"API HTTP server listen address."`
	MetricsListenAddress string                 `mapstructure:"metrics-listen-address" usage:"Prometheus /metrics HTTP endpoint listen address."`
	StorageAPIHost       string                 `mapstructure:"storage-api-host" usage:"Host of the Storage API."`
	Etcd                 etcdclient.Credentials `mapstructure:",squash" usage:"etcd client credentials."`
	EtcdConnectTimeout   time.Duration          `mapstructure:"connect-timeout" usage:"etcd connect timeout."`
	UniqueID             string                 `mapstructure:"unique-id" usage:"Unique process ID, auto-generated by default."`
	PublicAddress        *url.URL               `mapstructure:"public-address" usage:"Public address of the Templates API, to generate a link URL."`
	Repositories         Repositories           `mapstructure:"repositories" usage:"Default repositories, <name1>|<repo1>|<branch1>;..."`
	TasksCleanup         bool                   `mapstructure:"tasks-cleanup-enabled" usage:"Enable periodical tasks cleanup functionality."`
	TasksCleanupInterval time.Duration          `mapstructure:"tasks-cleanup-interval" usage:"How often will old tasks be deleted."`
}

type Repositories []model.TemplateRepository

type Option func(c *Config)

func DefaultRepositories() Repositories {
	return Repositories{
		{
			Type: model.RepositoryTypeGit,
			Name: "keboola",
			URL:  "https://github.com/keboola/keboola-as-code-templates.git",
			Ref:  "main",
		},
		{
			Type: model.RepositoryTypeGit,
			Name: "keboola-beta",
			URL:  "https://github.com/keboola/keboola-as-code-templates.git",
			Ref:  "beta",
		},
		{
			Type: model.RepositoryTypeGit,
			Name: "keboola-dev",
			URL:  "https://github.com/keboola/keboola-as-code-templates.git",
			Ref:  "dev",
		},
	}
}

func NewConfig() Config {
	return Config{
		DebugLog:             false,
		DebugEtcd:            false,
		DebugHTTP:            false,
		DatadogEnabled:       true,
		DatadogDebug:         false,
		CpuProfFilePath:      "",
		ListenAddress:        "0.0.0.0:8000",
		MetricsListenAddress: "0.0.0.0:9000",
		StorageAPIHost:       "",
		Etcd: etcdclient.Credentials{
			Endpoint:  "",
			Namespace: "",
			Username:  "",
			Password:  "",
		},
		EtcdConnectTimeout:   30 * time.Second, // longer default timeout, the etcd could be started at the same time as the API
		UniqueID:             "",
		PublicAddress:        nil,
		Repositories:         DefaultRepositories(),
		TasksCleanup:         true,
		TasksCleanupInterval: DefaultCleanupInterval,
	}
}

func LoadFrom(args []string, envs env.Provider) (Config, error) {
	cfg := NewConfig()
	err := cfg.LoadFrom(args, envs)
	return cfg, err
}

func (c *Config) LoadFrom(args []string, envs env.Provider) error {
	return configmap.LoadTo(c, args, envs, EnvPrefix)
}

func (c *Config) Dump() string {
	if kvs, err := configmap.Dump(c); err != nil {
		panic(err)
	} else {
		return kvs.String()
	}
}

func (c *Config) Normalize() {
	c.StorageAPIHost = strhelper.NormalizeHost(c.StorageAPIHost)
	c.Etcd.Normalize()
	if c.PublicAddress != nil {
		c.PublicAddress.Host = strhelper.NormalizeHost(c.PublicAddress.Host)
		if c.PublicAddress.Scheme == "" {
			c.PublicAddress.Scheme = "https"
		}
	}
}

func (c *Config) Validate() error {
	v := validator.New()
	errs := errors.NewMultiError()
	if c.TasksCleanupInterval <= 0 {
		return errors.Errorf(`tasks cleanup interval must be positive time.Duration, found "%v"`, c.TasksCleanupInterval)
	}
	if c.StorageAPIHost == "" {
		errs.Append(errors.New(`storage API host must be set`))
	}
	if err := c.Etcd.Validate(); err != nil {
		errs.Append(err)
	}
	if c.PublicAddress == nil || c.PublicAddress.String() == "" {
		errs.Append(errors.New("public address is not set"))
	}
	if c.ListenAddress == "" {
		errs.Append(errors.New("listen address is not set"))
	} else if err := v.ValidateValue(c.ListenAddress, "hostname_port"); err != nil {
		errs.Append(errors.Errorf(`listen address "%s" is not valid`, c.ListenAddress))
	}
	if c.MetricsListenAddress == "" {
		errs.Append(errors.New("metrics listen address is not set"))
	} else if err := v.ValidateValue(c.MetricsListenAddress, "hostname_port"); err != nil {
		errs.Append(errors.Errorf(`metrics address "%s" is not valid`, c.MetricsListenAddress))
	}
	if len(c.Repositories) == 0 {
		errs.Append(errors.New(`at least one default repository must be set`))
	}
	return errs.ErrorOrNil()
}

func (c Config) Apply(ops ...Option) Config {
	for _, o := range ops {
		o(&c)
	}
	return c
}

func WithDefaultRepositories(v []model.TemplateRepository) Option {
	return func(c *Config) {
		c.Repositories = v
	}
}

func WithCleanup(v bool) Option {
	return func(c *Config) {
		c.TasksCleanup = v
	}
}

func WithCleanupInterval(v time.Duration) Option {
	return func(c *Config) {
		c.TasksCleanupInterval = v
	}
}

func WithPublicAddress(v *url.URL) Option {
	return func(c *Config) {
		c.PublicAddress = v
	}
}

func WithListenAddress(v string) Option {
	return func(c *Config) {
		c.ListenAddress = v
	}
}
