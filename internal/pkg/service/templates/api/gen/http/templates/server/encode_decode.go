// Code generated by goa v3.18.2, DO NOT EDIT.
//
// templates HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/keboola/keboola-as-code/api/templates --output
// ./internal/pkg/service/templates/api

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strings"
	"unicode/utf8"

	templates "github.com/keboola/keboola-as-code/internal/pkg/service/templates/api/gen/templates"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeAPIVersionIndexResponse returns an encoder for responses returned by
// the templates ApiVersionIndex endpoint.
func EncodeAPIVersionIndexResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.ServiceDetail)
		enc := encoder(ctx, w)
		body := NewAPIVersionIndexResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeHealthCheckResponse returns an encoder for responses returned by the
// templates HealthCheck endpoint.
func EncodeHealthCheckResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(string)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "text/plain")
		enc := encoder(ctx, w)
		body := res
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeRepositoriesIndexResponse returns an encoder for responses returned by
// the templates RepositoriesIndex endpoint.
func EncodeRepositoriesIndexResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.Repositories)
		enc := encoder(ctx, w)
		body := NewRepositoriesIndexResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeRepositoriesIndexRequest returns a decoder for requests sent to the
// templates RepositoriesIndex endpoint.
func DecodeRepositoriesIndexRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			storageAPIToken string
			err             error
		)
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewRepositoriesIndexPayload(storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeRepositoryIndexResponse returns an encoder for responses returned by
// the templates RepositoryIndex endpoint.
func EncodeRepositoryIndexResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.Repository)
		enc := encoder(ctx, w)
		body := NewRepositoryIndexResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeRepositoryIndexRequest returns a decoder for requests sent to the
// templates RepositoryIndex endpoint.
func DecodeRepositoryIndexRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			repository      string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		repository = params["repository"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewRepositoryIndexPayload(repository, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeRepositoryIndexError returns an encoder for errors returned by the
// RepositoryIndex templates endpoint.
func EncodeRepositoryIndexError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.repositoryNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRepositoryIndexTemplatesRepositoryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeTemplatesIndexResponse returns an encoder for responses returned by
// the templates TemplatesIndex endpoint.
func EncodeTemplatesIndexResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.Templates)
		enc := encoder(ctx, w)
		body := NewTemplatesIndexResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeTemplatesIndexRequest returns a decoder for requests sent to the
// templates TemplatesIndex endpoint.
func DecodeTemplatesIndexRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			repository      string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		repository = params["repository"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewTemplatesIndexPayload(repository, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeTemplatesIndexError returns an encoder for errors returned by the
// TemplatesIndex templates endpoint.
func EncodeTemplatesIndexError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.repositoryNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewTemplatesIndexTemplatesRepositoryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeTemplateIndexResponse returns an encoder for responses returned by the
// templates TemplateIndex endpoint.
func EncodeTemplateIndexResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.TemplateDetail)
		enc := encoder(ctx, w)
		body := NewTemplateIndexResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeTemplateIndexRequest returns a decoder for requests sent to the
// templates TemplateIndex endpoint.
func DecodeTemplateIndexRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			repository      string
			template        string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		repository = params["repository"]
		template = params["template"]
		if utf8.RuneCountInString(template) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("template", template, utf8.RuneCountInString(template), 1, true))
		}
		if utf8.RuneCountInString(template) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("template", template, utf8.RuneCountInString(template), 40, false))
		}
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewTemplateIndexPayload(repository, template, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeTemplateIndexError returns an encoder for errors returned by the
// TemplateIndex templates endpoint.
func EncodeTemplateIndexError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.repositoryNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewTemplateIndexTemplatesRepositoryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.templateNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewTemplateIndexTemplatesTemplateNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeVersionIndexResponse returns an encoder for responses returned by the
// templates VersionIndex endpoint.
func EncodeVersionIndexResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.VersionDetailExtended)
		enc := encoder(ctx, w)
		body := NewVersionIndexResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeVersionIndexRequest returns a decoder for requests sent to the
// templates VersionIndex endpoint.
func DecodeVersionIndexRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			repository      string
			template        string
			version         string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		repository = params["repository"]
		template = params["template"]
		if utf8.RuneCountInString(template) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("template", template, utf8.RuneCountInString(template), 1, true))
		}
		if utf8.RuneCountInString(template) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("template", template, utf8.RuneCountInString(template), 40, false))
		}
		version = params["version"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewVersionIndexPayload(repository, template, version, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeVersionIndexError returns an encoder for errors returned by the
// VersionIndex templates endpoint.
func EncodeVersionIndexError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.repositoryNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewVersionIndexTemplatesRepositoryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.templateNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewVersionIndexTemplatesTemplateNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.versionNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewVersionIndexTemplatesVersionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeInputsIndexResponse returns an encoder for responses returned by the
// templates InputsIndex endpoint.
func EncodeInputsIndexResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.Inputs)
		enc := encoder(ctx, w)
		body := NewInputsIndexResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeInputsIndexRequest returns a decoder for requests sent to the
// templates InputsIndex endpoint.
func DecodeInputsIndexRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			repository      string
			template        string
			version         string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		repository = params["repository"]
		template = params["template"]
		if utf8.RuneCountInString(template) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("template", template, utf8.RuneCountInString(template), 1, true))
		}
		if utf8.RuneCountInString(template) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("template", template, utf8.RuneCountInString(template), 40, false))
		}
		version = params["version"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewInputsIndexPayload(repository, template, version, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeInputsIndexError returns an encoder for errors returned by the
// InputsIndex templates endpoint.
func EncodeInputsIndexError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.repositoryNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInputsIndexTemplatesRepositoryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.templateNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInputsIndexTemplatesTemplateNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.versionNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInputsIndexTemplatesVersionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeValidateInputsResponse returns an encoder for responses returned by
// the templates ValidateInputs endpoint.
func EncodeValidateInputsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.ValidationResult)
		enc := encoder(ctx, w)
		body := NewValidateInputsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeValidateInputsRequest returns a decoder for requests sent to the
// templates ValidateInputs endpoint.
func DecodeValidateInputsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body ValidateInputsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateValidateInputsRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			repository      string
			template        string
			version         string
			storageAPIToken string

			params = mux.Vars(r)
		)
		repository = params["repository"]
		template = params["template"]
		if utf8.RuneCountInString(template) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("template", template, utf8.RuneCountInString(template), 1, true))
		}
		if utf8.RuneCountInString(template) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("template", template, utf8.RuneCountInString(template), 40, false))
		}
		version = params["version"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewValidateInputsPayload(&body, repository, template, version, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeValidateInputsError returns an encoder for errors returned by the
// ValidateInputs templates endpoint.
func EncodeValidateInputsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.repositoryNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewValidateInputsTemplatesRepositoryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.templateNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewValidateInputsTemplatesTemplateNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.versionNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewValidateInputsTemplatesVersionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUseTemplateVersionResponse returns an encoder for responses returned
// by the templates UseTemplateVersion endpoint.
func EncodeUseTemplateVersionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.Task)
		enc := encoder(ctx, w)
		body := NewUseTemplateVersionResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeUseTemplateVersionRequest returns a decoder for requests sent to the
// templates UseTemplateVersion endpoint.
func DecodeUseTemplateVersionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UseTemplateVersionRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUseTemplateVersionRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			repository      string
			template        string
			version         string
			storageAPIToken string

			params = mux.Vars(r)
		)
		repository = params["repository"]
		template = params["template"]
		if utf8.RuneCountInString(template) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("template", template, utf8.RuneCountInString(template), 1, true))
		}
		if utf8.RuneCountInString(template) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("template", template, utf8.RuneCountInString(template), 40, false))
		}
		version = params["version"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUseTemplateVersionPayload(&body, repository, template, version, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUseTemplateVersionError returns an encoder for errors returned by the
// UseTemplateVersion templates endpoint.
func EncodeUseTemplateVersionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.repositoryNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUseTemplateVersionTemplatesRepositoryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.templateNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUseTemplateVersionTemplatesTemplateNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.versionNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUseTemplateVersionTemplatesVersionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.projectLocked":
			var res *templates.ProjectLockedError
			errors.As(v, &res)

			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUseTemplateVersionTemplatesProjectLockedResponseBody(res)
			}
			w.Header().Set("Retry-After", res.RetryAfter)
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "InvalidInputs":
			var res *templates.ValidationError
			errors.As(v, &res)

			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUseTemplateVersionInvalidInputsResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeInstancesIndexResponse returns an encoder for responses returned by
// the templates InstancesIndex endpoint.
func EncodeInstancesIndexResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.Instances)
		enc := encoder(ctx, w)
		body := NewInstancesIndexResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeInstancesIndexRequest returns a decoder for requests sent to the
// templates InstancesIndex endpoint.
func DecodeInstancesIndexRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branch          string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branch = params["branch"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewInstancesIndexPayload(branch, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeInstancesIndexError returns an encoder for errors returned by the
// InstancesIndex templates endpoint.
func EncodeInstancesIndexError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.branchNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInstancesIndexTemplatesBranchNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeInstanceIndexResponse returns an encoder for responses returned by the
// templates InstanceIndex endpoint.
func EncodeInstanceIndexResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.InstanceDetail)
		enc := encoder(ctx, w)
		body := NewInstanceIndexResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeInstanceIndexRequest returns a decoder for requests sent to the
// templates InstanceIndex endpoint.
func DecodeInstanceIndexRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branch          string
			instanceID      string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branch = params["branch"]
		instanceID = params["instanceId"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewInstanceIndexPayload(branch, instanceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeInstanceIndexError returns an encoder for errors returned by the
// InstanceIndex templates endpoint.
func EncodeInstanceIndexError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.branchNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInstanceIndexTemplatesBranchNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.repositoryNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInstanceIndexTemplatesRepositoryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.instanceNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInstanceIndexTemplatesInstanceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateInstanceResponse returns an encoder for responses returned by
// the templates UpdateInstance endpoint.
func EncodeUpdateInstanceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.InstanceDetail)
		enc := encoder(ctx, w)
		body := NewUpdateInstanceResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateInstanceRequest returns a decoder for requests sent to the
// templates UpdateInstance endpoint.
func DecodeUpdateInstanceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateInstanceRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateInstanceRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branch          string
			instanceID      string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branch = params["branch"]
		instanceID = params["instanceId"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateInstancePayload(&body, branch, instanceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpdateInstanceError returns an encoder for errors returned by the
// UpdateInstance templates endpoint.
func EncodeUpdateInstanceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.branchNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateInstanceTemplatesBranchNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.instanceNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateInstanceTemplatesInstanceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.projectLocked":
			var res *templates.ProjectLockedError
			errors.As(v, &res)

			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateInstanceTemplatesProjectLockedResponseBody(res)
			}
			w.Header().Set("Retry-After", res.RetryAfter)
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteInstanceResponse returns an encoder for responses returned by
// the templates DeleteInstance endpoint.
func EncodeDeleteInstanceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.Task)
		enc := encoder(ctx, w)
		body := NewDeleteInstanceResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeDeleteInstanceRequest returns a decoder for requests sent to the
// templates DeleteInstance endpoint.
func DecodeDeleteInstanceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branch          string
			instanceID      string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branch = params["branch"]
		instanceID = params["instanceId"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteInstancePayload(branch, instanceID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeDeleteInstanceError returns an encoder for errors returned by the
// DeleteInstance templates endpoint.
func EncodeDeleteInstanceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.branchNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteInstanceTemplatesBranchNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.instanceNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteInstanceTemplatesInstanceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.projectLocked":
			var res *templates.ProjectLockedError
			errors.As(v, &res)

			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteInstanceTemplatesProjectLockedResponseBody(res)
			}
			w.Header().Set("Retry-After", res.RetryAfter)
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpgradeInstanceResponse returns an encoder for responses returned by
// the templates UpgradeInstance endpoint.
func EncodeUpgradeInstanceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.Task)
		enc := encoder(ctx, w)
		body := NewUpgradeInstanceResponseBody(res)
		w.WriteHeader(http.StatusAccepted)
		return enc.Encode(body)
	}
}

// DecodeUpgradeInstanceRequest returns a decoder for requests sent to the
// templates UpgradeInstance endpoint.
func DecodeUpgradeInstanceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpgradeInstanceRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpgradeInstanceRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branch          string
			instanceID      string
			version         string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branch = params["branch"]
		instanceID = params["instanceId"]
		version = params["version"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpgradeInstancePayload(&body, branch, instanceID, version, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpgradeInstanceError returns an encoder for errors returned by the
// UpgradeInstance templates endpoint.
func EncodeUpgradeInstanceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.templateNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceTemplatesTemplateNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.branchNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceTemplatesBranchNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.instanceNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceTemplatesInstanceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.versionNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceTemplatesVersionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.projectLocked":
			var res *templates.ProjectLockedError
			errors.As(v, &res)

			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceTemplatesProjectLockedResponseBody(res)
			}
			w.Header().Set("Retry-After", res.RetryAfter)
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "InvalidInputs":
			var res *templates.ValidationError
			errors.As(v, &res)

			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceInvalidInputsResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpgradeInstanceInputsIndexResponse returns an encoder for responses
// returned by the templates UpgradeInstanceInputsIndex endpoint.
func EncodeUpgradeInstanceInputsIndexResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.Inputs)
		enc := encoder(ctx, w)
		body := NewUpgradeInstanceInputsIndexResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpgradeInstanceInputsIndexRequest returns a decoder for requests sent
// to the templates UpgradeInstanceInputsIndex endpoint.
func DecodeUpgradeInstanceInputsIndexRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			branch          string
			instanceID      string
			version         string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		branch = params["branch"]
		instanceID = params["instanceId"]
		version = params["version"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpgradeInstanceInputsIndexPayload(branch, instanceID, version, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpgradeInstanceInputsIndexError returns an encoder for errors returned
// by the UpgradeInstanceInputsIndex templates endpoint.
func EncodeUpgradeInstanceInputsIndexError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.templateNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceInputsIndexTemplatesTemplateNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.branchNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceInputsIndexTemplatesBranchNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.instanceNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceInputsIndexTemplatesInstanceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.versionNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceInputsIndexTemplatesVersionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpgradeInstanceValidateInputsResponse returns an encoder for responses
// returned by the templates UpgradeInstanceValidateInputs endpoint.
func EncodeUpgradeInstanceValidateInputsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.ValidationResult)
		enc := encoder(ctx, w)
		body := NewUpgradeInstanceValidateInputsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpgradeInstanceValidateInputsRequest returns a decoder for requests
// sent to the templates UpgradeInstanceValidateInputs endpoint.
func DecodeUpgradeInstanceValidateInputsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpgradeInstanceValidateInputsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpgradeInstanceValidateInputsRequestBody(&body, []string{"body"})
		if err != nil {
			return nil, err
		}

		var (
			branch          string
			instanceID      string
			version         string
			storageAPIToken string

			params = mux.Vars(r)
		)
		branch = params["branch"]
		instanceID = params["instanceId"]
		version = params["version"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpgradeInstanceValidateInputsPayload(&body, branch, instanceID, version, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeUpgradeInstanceValidateInputsError returns an encoder for errors
// returned by the UpgradeInstanceValidateInputs templates endpoint.
func EncodeUpgradeInstanceValidateInputsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.templateNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceValidateInputsTemplatesTemplateNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.branchNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceValidateInputsTemplatesBranchNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.instanceNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceValidateInputsTemplatesInstanceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "templates.versionNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpgradeInstanceValidateInputsTemplatesVersionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetTaskResponse returns an encoder for responses returned by the
// templates GetTask endpoint.
func EncodeGetTaskResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*templates.Task)
		enc := encoder(ctx, w)
		body := NewGetTaskResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetTaskRequest returns a decoder for requests sent to the templates
// GetTask endpoint.
func DecodeGetTaskRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			taskID          string
			storageAPIToken string
			err             error

			params = mux.Vars(r)
		)
		taskID = params["taskId"]
		storageAPIToken = r.Header.Get("X-StorageApi-Token")
		if storageAPIToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("X-StorageApi-Token", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetTaskPayload(taskID, storageAPIToken)
		if strings.Contains(payload.StorageAPIToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.StorageAPIToken, " ", 2)[1]
			payload.StorageAPIToken = cred
		}

		return payload, nil
	}
}

// EncodeGetTaskError returns an encoder for errors returned by the GetTask
// templates endpoint.
func EncodeGetTaskError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "templates.taskNotFound":
			var res *templates.GenericError
			errors.As(v, &res)
			res.StatusCode = http.StatusNotFound
			enc := encoder(ctx, w)
			var body any
			if false { // formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetTaskTemplatesTaskNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalTemplatesRepositoryToRepositoryResponseBody builds a value of type
// *RepositoryResponseBody from a value of type *templates.Repository.
func marshalTemplatesRepositoryToRepositoryResponseBody(v *templates.Repository) *RepositoryResponseBody {
	res := &RepositoryResponseBody{
		Name: v.Name,
		URL:  v.URL,
		Ref:  v.Ref,
	}
	if v.Author != nil {
		res.Author = marshalTemplatesAuthorToAuthorResponseBody(v.Author)
	}

	return res
}

// marshalTemplatesAuthorToAuthorResponseBody builds a value of type
// *AuthorResponseBody from a value of type *templates.Author.
func marshalTemplatesAuthorToAuthorResponseBody(v *templates.Author) *AuthorResponseBody {
	res := &AuthorResponseBody{
		Name: v.Name,
		URL:  v.URL,
	}

	return res
}

// marshalTemplatesTemplateToTemplateResponseBody builds a value of type
// *TemplateResponseBody from a value of type *templates.Template.
func marshalTemplatesTemplateToTemplateResponseBody(v *templates.Template) *TemplateResponseBody {
	res := &TemplateResponseBody{
		ID:             string(v.ID),
		Name:           v.Name,
		Deprecated:     v.Deprecated,
		Description:    v.Description,
		DefaultVersion: v.DefaultVersion,
	}
	if v.Author != nil {
		res.Author = marshalTemplatesAuthorToAuthorResponseBody(v.Author)
	}
	if v.Categories != nil {
		res.Categories = make([]string, len(v.Categories))
		for i, val := range v.Categories {
			res.Categories[i] = val
		}
	} else {
		res.Categories = []string{}
	}
	if v.Components != nil {
		res.Components = make([]string, len(v.Components))
		for i, val := range v.Components {
			res.Components[i] = val
		}
	} else {
		res.Components = []string{}
	}
	if v.Versions != nil {
		res.Versions = make([]*VersionResponseBody, len(v.Versions))
		for i, val := range v.Versions {
			res.Versions[i] = marshalTemplatesVersionToVersionResponseBody(val)
		}
	} else {
		res.Versions = []*VersionResponseBody{}
	}

	return res
}

// marshalTemplatesVersionToVersionResponseBody builds a value of type
// *VersionResponseBody from a value of type *templates.Version.
func marshalTemplatesVersionToVersionResponseBody(v *templates.Version) *VersionResponseBody {
	res := &VersionResponseBody{
		Version:     v.Version,
		Stable:      v.Stable,
		Description: v.Description,
	}

	return res
}

// marshalTemplatesStepGroupToStepGroupResponseBody builds a value of type
// *StepGroupResponseBody from a value of type *templates.StepGroup.
func marshalTemplatesStepGroupToStepGroupResponseBody(v *templates.StepGroup) *StepGroupResponseBody {
	res := &StepGroupResponseBody{
		ID:          v.ID,
		Description: v.Description,
		Required:    v.Required,
	}
	if v.Steps != nil {
		res.Steps = make([]*StepResponseBody, len(v.Steps))
		for i, val := range v.Steps {
			res.Steps[i] = marshalTemplatesStepToStepResponseBody(val)
		}
	} else {
		res.Steps = []*StepResponseBody{}
	}

	return res
}

// marshalTemplatesStepToStepResponseBody builds a value of type
// *StepResponseBody from a value of type *templates.Step.
func marshalTemplatesStepToStepResponseBody(v *templates.Step) *StepResponseBody {
	res := &StepResponseBody{
		ID:                v.ID,
		Icon:              v.Icon,
		Name:              v.Name,
		Description:       v.Description,
		DialogName:        v.DialogName,
		DialogDescription: v.DialogDescription,
	}
	if v.Inputs != nil {
		res.Inputs = make([]*InputResponseBody, len(v.Inputs))
		for i, val := range v.Inputs {
			res.Inputs[i] = marshalTemplatesInputToInputResponseBody(val)
		}
	} else {
		res.Inputs = []*InputResponseBody{}
	}

	return res
}

// marshalTemplatesInputToInputResponseBody builds a value of type
// *InputResponseBody from a value of type *templates.Input.
func marshalTemplatesInputToInputResponseBody(v *templates.Input) *InputResponseBody {
	res := &InputResponseBody{
		ID:           v.ID,
		Name:         v.Name,
		Description:  v.Description,
		Type:         v.Type,
		Kind:         v.Kind,
		Default:      v.Default,
		ComponentID:  v.ComponentID,
		OauthInputID: v.OauthInputID,
	}
	if v.Options != nil {
		res.Options = make([]*InputOptionResponseBody, len(v.Options))
		for i, val := range v.Options {
			res.Options[i] = marshalTemplatesInputOptionToInputOptionResponseBody(val)
		}
	}

	return res
}

// marshalTemplatesInputOptionToInputOptionResponseBody builds a value of type
// *InputOptionResponseBody from a value of type *templates.InputOption.
func marshalTemplatesInputOptionToInputOptionResponseBody(v *templates.InputOption) *InputOptionResponseBody {
	if v == nil {
		return nil
	}
	res := &InputOptionResponseBody{
		Label: v.Label,
		Value: v.Value,
	}

	return res
}

// marshalTemplatesValidationResultToValidationResultResponseBody builds a
// value of type *ValidationResultResponseBody from a value of type
// *templates.ValidationResult.
func marshalTemplatesValidationResultToValidationResultResponseBody(v *templates.ValidationResult) *ValidationResultResponseBody {
	res := &ValidationResultResponseBody{
		Valid: v.Valid,
	}
	if v.StepGroups != nil {
		res.StepGroups = make([]*StepGroupValidationResultResponseBody, len(v.StepGroups))
		for i, val := range v.StepGroups {
			res.StepGroups[i] = marshalTemplatesStepGroupValidationResultToStepGroupValidationResultResponseBody(val)
		}
	} else {
		res.StepGroups = []*StepGroupValidationResultResponseBody{}
	}

	return res
}

// marshalTemplatesStepGroupValidationResultToStepGroupValidationResultResponseBody
// builds a value of type *StepGroupValidationResultResponseBody from a value
// of type *templates.StepGroupValidationResult.
func marshalTemplatesStepGroupValidationResultToStepGroupValidationResultResponseBody(v *templates.StepGroupValidationResult) *StepGroupValidationResultResponseBody {
	res := &StepGroupValidationResultResponseBody{
		ID:    v.ID,
		Valid: v.Valid,
		Error: v.Error,
	}
	if v.Steps != nil {
		res.Steps = make([]*StepValidationResultResponseBody, len(v.Steps))
		for i, val := range v.Steps {
			res.Steps[i] = marshalTemplatesStepValidationResultToStepValidationResultResponseBody(val)
		}
	} else {
		res.Steps = []*StepValidationResultResponseBody{}
	}

	return res
}

// marshalTemplatesStepValidationResultToStepValidationResultResponseBody
// builds a value of type *StepValidationResultResponseBody from a value of
// type *templates.StepValidationResult.
func marshalTemplatesStepValidationResultToStepValidationResultResponseBody(v *templates.StepValidationResult) *StepValidationResultResponseBody {
	res := &StepValidationResultResponseBody{
		ID:         v.ID,
		Configured: v.Configured,
		Valid:      v.Valid,
	}
	if v.Inputs != nil {
		res.Inputs = make([]*InputValidationResultResponseBody, len(v.Inputs))
		for i, val := range v.Inputs {
			res.Inputs[i] = marshalTemplatesInputValidationResultToInputValidationResultResponseBody(val)
		}
	} else {
		res.Inputs = []*InputValidationResultResponseBody{}
	}

	return res
}

// marshalTemplatesInputValidationResultToInputValidationResultResponseBody
// builds a value of type *InputValidationResultResponseBody from a value of
// type *templates.InputValidationResult.
func marshalTemplatesInputValidationResultToInputValidationResultResponseBody(v *templates.InputValidationResult) *InputValidationResultResponseBody {
	res := &InputValidationResultResponseBody{
		ID:      v.ID,
		Visible: v.Visible,
		Error:   v.Error,
	}

	return res
}

// unmarshalStepPayloadRequestBodyToTemplatesStepPayload builds a value of type
// *templates.StepPayload from a value of type *StepPayloadRequestBody.
func unmarshalStepPayloadRequestBodyToTemplatesStepPayload(v *StepPayloadRequestBody) *templates.StepPayload {
	res := &templates.StepPayload{
		ID: *v.ID,
	}
	res.Inputs = make([]*templates.InputValue, len(v.Inputs))
	for i, val := range v.Inputs {
		res.Inputs[i] = unmarshalInputValueRequestBodyToTemplatesInputValue(val)
	}

	return res
}

// unmarshalInputValueRequestBodyToTemplatesInputValue builds a value of type
// *templates.InputValue from a value of type *InputValueRequestBody.
func unmarshalInputValueRequestBodyToTemplatesInputValue(v *InputValueRequestBody) *templates.InputValue {
	res := &templates.InputValue{
		ID:    *v.ID,
		Value: v.Value,
	}

	return res
}

// marshalTemplatesTaskOutputsToTaskOutputsResponseBody builds a value of type
// *TaskOutputsResponseBody from a value of type *templates.TaskOutputs.
func marshalTemplatesTaskOutputsToTaskOutputsResponseBody(v *templates.TaskOutputs) *TaskOutputsResponseBody {
	if v == nil {
		return nil
	}
	res := &TaskOutputsResponseBody{}
	if v.InstanceID != nil {
		instanceID := string(*v.InstanceID)
		res.InstanceID = &instanceID
	}

	return res
}

// marshalTemplatesInstanceToInstanceResponseBody builds a value of type
// *InstanceResponseBody from a value of type *templates.Instance.
func marshalTemplatesInstanceToInstanceResponseBody(v *templates.Instance) *InstanceResponseBody {
	res := &InstanceResponseBody{
		InstanceID:     string(v.InstanceID),
		TemplateID:     string(v.TemplateID),
		Version:        v.Version,
		RepositoryName: v.RepositoryName,
		Branch:         v.Branch,
		Name:           v.Name,
	}
	if v.Created != nil {
		res.Created = marshalTemplatesChangeInfoToChangeInfoResponseBody(v.Created)
	}
	if v.Updated != nil {
		res.Updated = marshalTemplatesChangeInfoToChangeInfoResponseBody(v.Updated)
	}
	if v.MainConfig != nil {
		res.MainConfig = marshalTemplatesMainConfigToMainConfigResponseBody(v.MainConfig)
	}
	if v.Configurations != nil {
		res.Configurations = make([]*ConfigResponseBody, len(v.Configurations))
		for i, val := range v.Configurations {
			res.Configurations[i] = marshalTemplatesConfigToConfigResponseBody(val)
		}
	} else {
		res.Configurations = []*ConfigResponseBody{}
	}

	return res
}

// marshalTemplatesChangeInfoToChangeInfoResponseBody builds a value of type
// *ChangeInfoResponseBody from a value of type *templates.ChangeInfo.
func marshalTemplatesChangeInfoToChangeInfoResponseBody(v *templates.ChangeInfo) *ChangeInfoResponseBody {
	res := &ChangeInfoResponseBody{
		Date:    v.Date,
		TokenID: v.TokenID,
	}

	return res
}

// marshalTemplatesMainConfigToMainConfigResponseBody builds a value of type
// *MainConfigResponseBody from a value of type *templates.MainConfig.
func marshalTemplatesMainConfigToMainConfigResponseBody(v *templates.MainConfig) *MainConfigResponseBody {
	if v == nil {
		return nil
	}
	res := &MainConfigResponseBody{
		ComponentID: v.ComponentID,
		ConfigID:    v.ConfigID,
	}

	return res
}

// marshalTemplatesConfigToConfigResponseBody builds a value of type
// *ConfigResponseBody from a value of type *templates.Config.
func marshalTemplatesConfigToConfigResponseBody(v *templates.Config) *ConfigResponseBody {
	res := &ConfigResponseBody{
		ComponentID: v.ComponentID,
		ConfigID:    v.ConfigID,
		Name:        v.Name,
	}

	return res
}

// marshalTemplatesTemplateBaseToTemplateBaseResponseBody builds a value of
// type *TemplateBaseResponseBody from a value of type *templates.TemplateBase.
func marshalTemplatesTemplateBaseToTemplateBaseResponseBody(v *templates.TemplateBase) *TemplateBaseResponseBody {
	res := &TemplateBaseResponseBody{
		ID:             string(v.ID),
		Name:           v.Name,
		Deprecated:     v.Deprecated,
		Description:    v.Description,
		DefaultVersion: v.DefaultVersion,
	}
	if v.Author != nil {
		res.Author = marshalTemplatesAuthorToAuthorResponseBody(v.Author)
	}

	return res
}

// marshalTemplatesVersionDetailToVersionDetailResponseBody builds a value of
// type *VersionDetailResponseBody from a value of type
// *templates.VersionDetail.
func marshalTemplatesVersionDetailToVersionDetailResponseBody(v *templates.VersionDetail) *VersionDetailResponseBody {
	res := &VersionDetailResponseBody{
		Version:         v.Version,
		Stable:          v.Stable,
		Description:     v.Description,
		LongDescription: v.LongDescription,
		Readme:          v.Readme,
	}
	if v.Components != nil {
		res.Components = make([]string, len(v.Components))
		for i, val := range v.Components {
			res.Components[i] = val
		}
	} else {
		res.Components = []string{}
	}

	return res
}
