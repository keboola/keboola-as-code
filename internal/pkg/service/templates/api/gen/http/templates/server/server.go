// Code generated by goa v3.19.1, DO NOT EDIT.
//
// templates HTTP server
//
// Command:
// $ goa gen github.com/keboola/keboola-as-code/api/templates --output
// ./internal/pkg/service/templates/api

package server

import (
	"context"
	"net/http"
	"path"

	templates "github.com/keboola/keboola-as-code/internal/pkg/service/templates/api/gen/templates"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
	"goa.design/plugins/v3/cors"
)

// Server lists the templates service endpoint HTTP handlers.
type Server struct {
	Mounts                        []*MountPoint
	APIRootIndex                  http.Handler
	APIVersionIndex               http.Handler
	HealthCheck                   http.Handler
	RepositoriesIndex             http.Handler
	RepositoryIndex               http.Handler
	TemplatesIndex                http.Handler
	TemplateIndex                 http.Handler
	VersionIndex                  http.Handler
	InputsIndex                   http.Handler
	ValidateInputs                http.Handler
	UseTemplateVersion            http.Handler
	Preview                       http.Handler
	InstancesIndex                http.Handler
	InstanceIndex                 http.Handler
	UpdateInstance                http.Handler
	DeleteInstance                http.Handler
	UpgradeInstance               http.Handler
	UpgradeInstanceInputsIndex    http.Handler
	UpgradeInstanceValidateInputs http.Handler
	GetTask                       http.Handler
	CORS                          http.Handler
	OpenapiJSON                   http.Handler
	OpenapiYaml                   http.Handler
	Openapi3JSON                  http.Handler
	Openapi3Yaml                  http.Handler
	SwaggerUI                     http.Handler
}

// MountPoint holds information about the mounted endpoints.
type MountPoint struct {
	// Method is the name of the service method served by the mounted HTTP handler.
	Method string
	// Verb is the HTTP method used to match requests to the mounted handler.
	Verb string
	// Pattern is the HTTP request path pattern used to match requests to the
	// mounted handler.
	Pattern string
}

// New instantiates HTTP handlers for all the templates service endpoints using
// the provided encoder and decoder. The handlers are mounted on the given mux
// using the HTTP verb and path defined in the design. errhandler is called
// whenever a response fails to be encoded. formatter is used to format errors
// returned by the service methods prior to encoding. Both errhandler and
// formatter are optional and can be nil.
func New(
	e *templates.Endpoints,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
	fileSystemOpenapiJSON http.FileSystem,
	fileSystemOpenapiYaml http.FileSystem,
	fileSystemOpenapi3JSON http.FileSystem,
	fileSystemOpenapi3Yaml http.FileSystem,
	fileSystemSwaggerUI http.FileSystem,
) *Server {
	if fileSystemOpenapiJSON == nil {
		fileSystemOpenapiJSON = http.Dir(".")
	}
	if fileSystemOpenapiYaml == nil {
		fileSystemOpenapiYaml = http.Dir(".")
	}
	if fileSystemOpenapi3JSON == nil {
		fileSystemOpenapi3JSON = http.Dir(".")
	}
	if fileSystemOpenapi3Yaml == nil {
		fileSystemOpenapi3Yaml = http.Dir(".")
	}
	if fileSystemSwaggerUI == nil {
		fileSystemSwaggerUI = http.Dir(".")
	}
	fileSystemSwaggerUI = appendPrefix(fileSystemSwaggerUI, "/swagger-ui")
	return &Server{
		Mounts: []*MountPoint{
			{"APIRootIndex", "GET", "/"},
			{"APIVersionIndex", "GET", "/v1"},
			{"HealthCheck", "GET", "/health-check"},
			{"RepositoriesIndex", "GET", "/v1/repositories"},
			{"RepositoryIndex", "GET", "/v1/repositories/{repository}"},
			{"TemplatesIndex", "GET", "/v1/repositories/{repository}/templates"},
			{"TemplateIndex", "GET", "/v1/repositories/{repository}/templates/{template}"},
			{"VersionIndex", "GET", "/v1/repositories/{repository}/templates/{template}/{version}"},
			{"InputsIndex", "GET", "/v1/repositories/{repository}/templates/{template}/{version}/inputs"},
			{"ValidateInputs", "POST", "/v1/repositories/{repository}/templates/{template}/{version}/validate"},
			{"UseTemplateVersion", "POST", "/v1/repositories/{repository}/templates/{template}/{version}/use"},
			{"Preview", "POST", "/v1/repositories/{repository}/templates/{template}/{version}/preview"},
			{"InstancesIndex", "GET", "/v1/project/{branch}/instances"},
			{"InstanceIndex", "GET", "/v1/project/{branch}/instances/{instanceId}"},
			{"UpdateInstance", "PUT", "/v1/project/{branch}/instances/{instanceId}"},
			{"DeleteInstance", "DELETE", "/v1/project/{branch}/instances/{instanceId}"},
			{"UpgradeInstance", "POST", "/v1/project/{branch}/instances/{instanceId}/upgrade/{version}"},
			{"UpgradeInstanceInputsIndex", "GET", "/v1/project/{branch}/instances/{instanceId}/upgrade/{version}/inputs"},
			{"UpgradeInstanceValidateInputs", "POST", "/v1/project/{branch}/instances/{instanceId}/upgrade/{version}/inputs"},
			{"GetTask", "GET", "/v1/tasks/{*taskId}"},
			{"CORS", "OPTIONS", "/"},
			{"CORS", "OPTIONS", "/v1"},
			{"CORS", "OPTIONS", "/health-check"},
			{"CORS", "OPTIONS", "/v1/repositories"},
			{"CORS", "OPTIONS", "/v1/repositories/{repository}"},
			{"CORS", "OPTIONS", "/v1/repositories/{repository}/templates"},
			{"CORS", "OPTIONS", "/v1/repositories/{repository}/templates/{template}"},
			{"CORS", "OPTIONS", "/v1/repositories/{repository}/templates/{template}/{version}"},
			{"CORS", "OPTIONS", "/v1/repositories/{repository}/templates/{template}/{version}/inputs"},
			{"CORS", "OPTIONS", "/v1/repositories/{repository}/templates/{template}/{version}/validate"},
			{"CORS", "OPTIONS", "/v1/repositories/{repository}/templates/{template}/{version}/use"},
			{"CORS", "OPTIONS", "/v1/repositories/{repository}/templates/{template}/{version}/preview"},
			{"CORS", "OPTIONS", "/v1/project/{branch}/instances"},
			{"CORS", "OPTIONS", "/v1/project/{branch}/instances/{instanceId}"},
			{"CORS", "OPTIONS", "/v1/project/{branch}/instances/{instanceId}/upgrade/{version}"},
			{"CORS", "OPTIONS", "/v1/project/{branch}/instances/{instanceId}/upgrade/{version}/inputs"},
			{"CORS", "OPTIONS", "/v1/tasks/{*taskId}"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi.json"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi.yaml"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi3.json"},
			{"CORS", "OPTIONS", "/v1/documentation/openapi3.yaml"},
			{"CORS", "OPTIONS", "/v1/documentation/{*path}"},
			{"Serve openapi.json", "GET", "/v1/documentation/openapi.json"},
			{"Serve openapi.yaml", "GET", "/v1/documentation/openapi.yaml"},
			{"Serve openapi3.json", "GET", "/v1/documentation/openapi3.json"},
			{"Serve openapi3.yaml", "GET", "/v1/documentation/openapi3.yaml"},
			{"Serve swagger-ui", "GET", "/v1/documentation"},
		},
		APIRootIndex:                  NewAPIRootIndexHandler(e.APIRootIndex, mux, decoder, encoder, errhandler, formatter),
		APIVersionIndex:               NewAPIVersionIndexHandler(e.APIVersionIndex, mux, decoder, encoder, errhandler, formatter),
		HealthCheck:                   NewHealthCheckHandler(e.HealthCheck, mux, decoder, encoder, errhandler, formatter),
		RepositoriesIndex:             NewRepositoriesIndexHandler(e.RepositoriesIndex, mux, decoder, encoder, errhandler, formatter),
		RepositoryIndex:               NewRepositoryIndexHandler(e.RepositoryIndex, mux, decoder, encoder, errhandler, formatter),
		TemplatesIndex:                NewTemplatesIndexHandler(e.TemplatesIndex, mux, decoder, encoder, errhandler, formatter),
		TemplateIndex:                 NewTemplateIndexHandler(e.TemplateIndex, mux, decoder, encoder, errhandler, formatter),
		VersionIndex:                  NewVersionIndexHandler(e.VersionIndex, mux, decoder, encoder, errhandler, formatter),
		InputsIndex:                   NewInputsIndexHandler(e.InputsIndex, mux, decoder, encoder, errhandler, formatter),
		ValidateInputs:                NewValidateInputsHandler(e.ValidateInputs, mux, decoder, encoder, errhandler, formatter),
		UseTemplateVersion:            NewUseTemplateVersionHandler(e.UseTemplateVersion, mux, decoder, encoder, errhandler, formatter),
		Preview:                       NewPreviewHandler(e.Preview, mux, decoder, encoder, errhandler, formatter),
		InstancesIndex:                NewInstancesIndexHandler(e.InstancesIndex, mux, decoder, encoder, errhandler, formatter),
		InstanceIndex:                 NewInstanceIndexHandler(e.InstanceIndex, mux, decoder, encoder, errhandler, formatter),
		UpdateInstance:                NewUpdateInstanceHandler(e.UpdateInstance, mux, decoder, encoder, errhandler, formatter),
		DeleteInstance:                NewDeleteInstanceHandler(e.DeleteInstance, mux, decoder, encoder, errhandler, formatter),
		UpgradeInstance:               NewUpgradeInstanceHandler(e.UpgradeInstance, mux, decoder, encoder, errhandler, formatter),
		UpgradeInstanceInputsIndex:    NewUpgradeInstanceInputsIndexHandler(e.UpgradeInstanceInputsIndex, mux, decoder, encoder, errhandler, formatter),
		UpgradeInstanceValidateInputs: NewUpgradeInstanceValidateInputsHandler(e.UpgradeInstanceValidateInputs, mux, decoder, encoder, errhandler, formatter),
		GetTask:                       NewGetTaskHandler(e.GetTask, mux, decoder, encoder, errhandler, formatter),
		CORS:                          NewCORSHandler(),
		OpenapiJSON:                   http.FileServer(fileSystemOpenapiJSON),
		OpenapiYaml:                   http.FileServer(fileSystemOpenapiYaml),
		Openapi3JSON:                  http.FileServer(fileSystemOpenapi3JSON),
		Openapi3Yaml:                  http.FileServer(fileSystemOpenapi3Yaml),
		SwaggerUI:                     http.FileServer(fileSystemSwaggerUI),
	}
}

// Service returns the name of the service served.
func (s *Server) Service() string { return "templates" }

// Use wraps the server handlers with the given middleware.
func (s *Server) Use(m func(http.Handler) http.Handler) {
	s.APIRootIndex = m(s.APIRootIndex)
	s.APIVersionIndex = m(s.APIVersionIndex)
	s.HealthCheck = m(s.HealthCheck)
	s.RepositoriesIndex = m(s.RepositoriesIndex)
	s.RepositoryIndex = m(s.RepositoryIndex)
	s.TemplatesIndex = m(s.TemplatesIndex)
	s.TemplateIndex = m(s.TemplateIndex)
	s.VersionIndex = m(s.VersionIndex)
	s.InputsIndex = m(s.InputsIndex)
	s.ValidateInputs = m(s.ValidateInputs)
	s.UseTemplateVersion = m(s.UseTemplateVersion)
	s.Preview = m(s.Preview)
	s.InstancesIndex = m(s.InstancesIndex)
	s.InstanceIndex = m(s.InstanceIndex)
	s.UpdateInstance = m(s.UpdateInstance)
	s.DeleteInstance = m(s.DeleteInstance)
	s.UpgradeInstance = m(s.UpgradeInstance)
	s.UpgradeInstanceInputsIndex = m(s.UpgradeInstanceInputsIndex)
	s.UpgradeInstanceValidateInputs = m(s.UpgradeInstanceValidateInputs)
	s.GetTask = m(s.GetTask)
	s.CORS = m(s.CORS)
}

// MethodNames returns the methods served.
func (s *Server) MethodNames() []string { return templates.MethodNames[:] }

// Mount configures the mux to serve the templates endpoints.
func Mount(mux goahttp.Muxer, h *Server) {
	MountAPIRootIndexHandler(mux, h.APIRootIndex)
	MountAPIVersionIndexHandler(mux, h.APIVersionIndex)
	MountHealthCheckHandler(mux, h.HealthCheck)
	MountRepositoriesIndexHandler(mux, h.RepositoriesIndex)
	MountRepositoryIndexHandler(mux, h.RepositoryIndex)
	MountTemplatesIndexHandler(mux, h.TemplatesIndex)
	MountTemplateIndexHandler(mux, h.TemplateIndex)
	MountVersionIndexHandler(mux, h.VersionIndex)
	MountInputsIndexHandler(mux, h.InputsIndex)
	MountValidateInputsHandler(mux, h.ValidateInputs)
	MountUseTemplateVersionHandler(mux, h.UseTemplateVersion)
	MountPreviewHandler(mux, h.Preview)
	MountInstancesIndexHandler(mux, h.InstancesIndex)
	MountInstanceIndexHandler(mux, h.InstanceIndex)
	MountUpdateInstanceHandler(mux, h.UpdateInstance)
	MountDeleteInstanceHandler(mux, h.DeleteInstance)
	MountUpgradeInstanceHandler(mux, h.UpgradeInstance)
	MountUpgradeInstanceInputsIndexHandler(mux, h.UpgradeInstanceInputsIndex)
	MountUpgradeInstanceValidateInputsHandler(mux, h.UpgradeInstanceValidateInputs)
	MountGetTaskHandler(mux, h.GetTask)
	MountCORSHandler(mux, h.CORS)
	MountOpenapiJSON(mux, http.StripPrefix("/v1/documentation", h.OpenapiJSON))
	MountOpenapiYaml(mux, http.StripPrefix("/v1/documentation", h.OpenapiYaml))
	MountOpenapi3JSON(mux, http.StripPrefix("/v1/documentation", h.Openapi3JSON))
	MountOpenapi3Yaml(mux, http.StripPrefix("/v1/documentation", h.Openapi3Yaml))
	MountSwaggerUI(mux, http.StripPrefix("/v1/documentation", h.SwaggerUI))
}

// Mount configures the mux to serve the templates endpoints.
func (s *Server) Mount(mux goahttp.Muxer) {
	Mount(mux, s)
}

// MountAPIRootIndexHandler configures the mux to serve the "templates" service
// "ApiRootIndex" endpoint.
func MountAPIRootIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/", f)
}

// NewAPIRootIndexHandler creates a HTTP handler which loads the HTTP request
// and calls the "templates" service "ApiRootIndex" endpoint.
func NewAPIRootIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ApiRootIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		http.Redirect(w, r, "/v1", http.StatusMovedPermanently)
	})
}

// MountAPIVersionIndexHandler configures the mux to serve the "templates"
// service "ApiVersionIndex" endpoint.
func MountAPIVersionIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1", f)
}

// NewAPIVersionIndexHandler creates a HTTP handler which loads the HTTP
// request and calls the "templates" service "ApiVersionIndex" endpoint.
func NewAPIVersionIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		encodeResponse = EncodeAPIVersionIndexResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ApiVersionIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		var err error
		res, err := endpoint(ctx, nil)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountHealthCheckHandler configures the mux to serve the "templates" service
// "HealthCheck" endpoint.
func MountHealthCheckHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/health-check", f)
}

// NewHealthCheckHandler creates a HTTP handler which loads the HTTP request
// and calls the "templates" service "HealthCheck" endpoint.
func NewHealthCheckHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		encodeResponse = EncodeHealthCheckResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "HealthCheck")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		var err error
		res, err := endpoint(ctx, nil)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountRepositoriesIndexHandler configures the mux to serve the "templates"
// service "RepositoriesIndex" endpoint.
func MountRepositoriesIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/repositories", f)
}

// NewRepositoriesIndexHandler creates a HTTP handler which loads the HTTP
// request and calls the "templates" service "RepositoriesIndex" endpoint.
func NewRepositoriesIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeRepositoriesIndexRequest(mux, decoder)
		encodeResponse = EncodeRepositoriesIndexResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "RepositoriesIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountRepositoryIndexHandler configures the mux to serve the "templates"
// service "RepositoryIndex" endpoint.
func MountRepositoryIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/repositories/{repository}", f)
}

// NewRepositoryIndexHandler creates a HTTP handler which loads the HTTP
// request and calls the "templates" service "RepositoryIndex" endpoint.
func NewRepositoryIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeRepositoryIndexRequest(mux, decoder)
		encodeResponse = EncodeRepositoryIndexResponse(encoder)
		encodeError    = EncodeRepositoryIndexError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "RepositoryIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountTemplatesIndexHandler configures the mux to serve the "templates"
// service "TemplatesIndex" endpoint.
func MountTemplatesIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/repositories/{repository}/templates", f)
}

// NewTemplatesIndexHandler creates a HTTP handler which loads the HTTP request
// and calls the "templates" service "TemplatesIndex" endpoint.
func NewTemplatesIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeTemplatesIndexRequest(mux, decoder)
		encodeResponse = EncodeTemplatesIndexResponse(encoder)
		encodeError    = EncodeTemplatesIndexError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "TemplatesIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountTemplateIndexHandler configures the mux to serve the "templates"
// service "TemplateIndex" endpoint.
func MountTemplateIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/repositories/{repository}/templates/{template}", f)
}

// NewTemplateIndexHandler creates a HTTP handler which loads the HTTP request
// and calls the "templates" service "TemplateIndex" endpoint.
func NewTemplateIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeTemplateIndexRequest(mux, decoder)
		encodeResponse = EncodeTemplateIndexResponse(encoder)
		encodeError    = EncodeTemplateIndexError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "TemplateIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountVersionIndexHandler configures the mux to serve the "templates" service
// "VersionIndex" endpoint.
func MountVersionIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/repositories/{repository}/templates/{template}/{version}", f)
}

// NewVersionIndexHandler creates a HTTP handler which loads the HTTP request
// and calls the "templates" service "VersionIndex" endpoint.
func NewVersionIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeVersionIndexRequest(mux, decoder)
		encodeResponse = EncodeVersionIndexResponse(encoder)
		encodeError    = EncodeVersionIndexError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "VersionIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountInputsIndexHandler configures the mux to serve the "templates" service
// "InputsIndex" endpoint.
func MountInputsIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/repositories/{repository}/templates/{template}/{version}/inputs", f)
}

// NewInputsIndexHandler creates a HTTP handler which loads the HTTP request
// and calls the "templates" service "InputsIndex" endpoint.
func NewInputsIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeInputsIndexRequest(mux, decoder)
		encodeResponse = EncodeInputsIndexResponse(encoder)
		encodeError    = EncodeInputsIndexError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "InputsIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountValidateInputsHandler configures the mux to serve the "templates"
// service "ValidateInputs" endpoint.
func MountValidateInputsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/repositories/{repository}/templates/{template}/{version}/validate", f)
}

// NewValidateInputsHandler creates a HTTP handler which loads the HTTP request
// and calls the "templates" service "ValidateInputs" endpoint.
func NewValidateInputsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeValidateInputsRequest(mux, decoder)
		encodeResponse = EncodeValidateInputsResponse(encoder)
		encodeError    = EncodeValidateInputsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ValidateInputs")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUseTemplateVersionHandler configures the mux to serve the "templates"
// service "UseTemplateVersion" endpoint.
func MountUseTemplateVersionHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/repositories/{repository}/templates/{template}/{version}/use", f)
}

// NewUseTemplateVersionHandler creates a HTTP handler which loads the HTTP
// request and calls the "templates" service "UseTemplateVersion" endpoint.
func NewUseTemplateVersionHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUseTemplateVersionRequest(mux, decoder)
		encodeResponse = EncodeUseTemplateVersionResponse(encoder)
		encodeError    = EncodeUseTemplateVersionError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UseTemplateVersion")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountPreviewHandler configures the mux to serve the "templates" service
// "Preview" endpoint.
func MountPreviewHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/repositories/{repository}/templates/{template}/{version}/preview", f)
}

// NewPreviewHandler creates a HTTP handler which loads the HTTP request and
// calls the "templates" service "Preview" endpoint.
func NewPreviewHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodePreviewRequest(mux, decoder)
		encodeResponse = EncodePreviewResponse(encoder)
		encodeError    = EncodePreviewError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "Preview")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountInstancesIndexHandler configures the mux to serve the "templates"
// service "InstancesIndex" endpoint.
func MountInstancesIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/project/{branch}/instances", f)
}

// NewInstancesIndexHandler creates a HTTP handler which loads the HTTP request
// and calls the "templates" service "InstancesIndex" endpoint.
func NewInstancesIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeInstancesIndexRequest(mux, decoder)
		encodeResponse = EncodeInstancesIndexResponse(encoder)
		encodeError    = EncodeInstancesIndexError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "InstancesIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountInstanceIndexHandler configures the mux to serve the "templates"
// service "InstanceIndex" endpoint.
func MountInstanceIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/project/{branch}/instances/{instanceId}", f)
}

// NewInstanceIndexHandler creates a HTTP handler which loads the HTTP request
// and calls the "templates" service "InstanceIndex" endpoint.
func NewInstanceIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeInstanceIndexRequest(mux, decoder)
		encodeResponse = EncodeInstanceIndexResponse(encoder)
		encodeError    = EncodeInstanceIndexError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "InstanceIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateInstanceHandler configures the mux to serve the "templates"
// service "UpdateInstance" endpoint.
func MountUpdateInstanceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PUT", "/v1/project/{branch}/instances/{instanceId}", f)
}

// NewUpdateInstanceHandler creates a HTTP handler which loads the HTTP request
// and calls the "templates" service "UpdateInstance" endpoint.
func NewUpdateInstanceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateInstanceRequest(mux, decoder)
		encodeResponse = EncodeUpdateInstanceResponse(encoder)
		encodeError    = EncodeUpdateInstanceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateInstance")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteInstanceHandler configures the mux to serve the "templates"
// service "DeleteInstance" endpoint.
func MountDeleteInstanceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/v1/project/{branch}/instances/{instanceId}", f)
}

// NewDeleteInstanceHandler creates a HTTP handler which loads the HTTP request
// and calls the "templates" service "DeleteInstance" endpoint.
func NewDeleteInstanceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteInstanceRequest(mux, decoder)
		encodeResponse = EncodeDeleteInstanceResponse(encoder)
		encodeError    = EncodeDeleteInstanceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteInstance")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpgradeInstanceHandler configures the mux to serve the "templates"
// service "UpgradeInstance" endpoint.
func MountUpgradeInstanceHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/project/{branch}/instances/{instanceId}/upgrade/{version}", f)
}

// NewUpgradeInstanceHandler creates a HTTP handler which loads the HTTP
// request and calls the "templates" service "UpgradeInstance" endpoint.
func NewUpgradeInstanceHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpgradeInstanceRequest(mux, decoder)
		encodeResponse = EncodeUpgradeInstanceResponse(encoder)
		encodeError    = EncodeUpgradeInstanceError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpgradeInstance")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpgradeInstanceInputsIndexHandler configures the mux to serve the
// "templates" service "UpgradeInstanceInputsIndex" endpoint.
func MountUpgradeInstanceInputsIndexHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/project/{branch}/instances/{instanceId}/upgrade/{version}/inputs", f)
}

// NewUpgradeInstanceInputsIndexHandler creates a HTTP handler which loads the
// HTTP request and calls the "templates" service "UpgradeInstanceInputsIndex"
// endpoint.
func NewUpgradeInstanceInputsIndexHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpgradeInstanceInputsIndexRequest(mux, decoder)
		encodeResponse = EncodeUpgradeInstanceInputsIndexResponse(encoder)
		encodeError    = EncodeUpgradeInstanceInputsIndexError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpgradeInstanceInputsIndex")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpgradeInstanceValidateInputsHandler configures the mux to serve the
// "templates" service "UpgradeInstanceValidateInputs" endpoint.
func MountUpgradeInstanceValidateInputsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/project/{branch}/instances/{instanceId}/upgrade/{version}/inputs", f)
}

// NewUpgradeInstanceValidateInputsHandler creates a HTTP handler which loads
// the HTTP request and calls the "templates" service
// "UpgradeInstanceValidateInputs" endpoint.
func NewUpgradeInstanceValidateInputsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpgradeInstanceValidateInputsRequest(mux, decoder)
		encodeResponse = EncodeUpgradeInstanceValidateInputsResponse(encoder)
		encodeError    = EncodeUpgradeInstanceValidateInputsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpgradeInstanceValidateInputs")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetTaskHandler configures the mux to serve the "templates" service
// "GetTask" endpoint.
func MountGetTaskHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleTemplatesOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/tasks/{*taskId}", f)
}

// NewGetTaskHandler creates a HTTP handler which loads the HTTP request and
// calls the "templates" service "GetTask" endpoint.
func NewGetTaskHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetTaskRequest(mux, decoder)
		encodeResponse = EncodeGetTaskResponse(encoder)
		encodeError    = EncodeGetTaskError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetTask")
		ctx = context.WithValue(ctx, goa.ServiceKey, "templates")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// appendFS is a custom implementation of fs.FS that appends a specified prefix
// to the file paths before delegating the Open call to the underlying fs.FS.
type appendFS struct {
	prefix string
	fs     http.FileSystem
}

// Open opens the named file, appending the prefix to the file path before
// passing it to the underlying fs.FS.
func (s appendFS) Open(name string) (http.File, error) {
	switch name {
	}
	return s.fs.Open(path.Join(s.prefix, name))
}

// appendPrefix returns a new fs.FS that appends the specified prefix to file paths
// before delegating to the provided embed.FS.
func appendPrefix(fsys http.FileSystem, prefix string) http.FileSystem {
	return appendFS{prefix: prefix, fs: fsys}
}

// MountOpenapiJSON configures the mux to serve GET request made to
// "/v1/documentation/openapi.json".
func MountOpenapiJSON(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi.json", HandleTemplatesOrigin(h).ServeHTTP)
}

// MountOpenapiYaml configures the mux to serve GET request made to
// "/v1/documentation/openapi.yaml".
func MountOpenapiYaml(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi.yaml", HandleTemplatesOrigin(h).ServeHTTP)
}

// MountOpenapi3JSON configures the mux to serve GET request made to
// "/v1/documentation/openapi3.json".
func MountOpenapi3JSON(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi3.json", HandleTemplatesOrigin(h).ServeHTTP)
}

// MountOpenapi3Yaml configures the mux to serve GET request made to
// "/v1/documentation/openapi3.yaml".
func MountOpenapi3Yaml(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/openapi3.yaml", HandleTemplatesOrigin(h).ServeHTTP)
}

// MountSwaggerUI configures the mux to serve GET request made to
// "/v1/documentation".
func MountSwaggerUI(mux goahttp.Muxer, h http.Handler) {
	mux.Handle("GET", "/v1/documentation/", HandleTemplatesOrigin(h).ServeHTTP)
	mux.Handle("GET", "/v1/documentation/{*path}", HandleTemplatesOrigin(h).ServeHTTP)
}

// MountCORSHandler configures the mux to serve the CORS endpoints for the
// service templates.
func MountCORSHandler(mux goahttp.Muxer, h http.Handler) {
	h = HandleTemplatesOrigin(h)
	mux.Handle("OPTIONS", "/", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1", h.ServeHTTP)
	mux.Handle("OPTIONS", "/health-check", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/repositories", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/repositories/{repository}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/repositories/{repository}/templates", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/repositories/{repository}/templates/{template}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/repositories/{repository}/templates/{template}/{version}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/repositories/{repository}/templates/{template}/{version}/inputs", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/repositories/{repository}/templates/{template}/{version}/validate", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/repositories/{repository}/templates/{template}/{version}/use", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/repositories/{repository}/templates/{template}/{version}/preview", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/project/{branch}/instances", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/project/{branch}/instances/{instanceId}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/project/{branch}/instances/{instanceId}/upgrade/{version}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/project/{branch}/instances/{instanceId}/upgrade/{version}/inputs", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/tasks/{*taskId}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi.json", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi.yaml", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi3.json", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/openapi3.yaml", h.ServeHTTP)
	mux.Handle("OPTIONS", "/v1/documentation/{*path}", h.ServeHTTP)
}

// NewCORSHandler creates a HTTP handler which returns a simple 204 response.
func NewCORSHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(204)
	})
}

// HandleTemplatesOrigin applies the CORS response headers corresponding to the
// origin for the service templates.
func HandleTemplatesOrigin(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		origin := r.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			h.ServeHTTP(w, r)
			return
		}
		if cors.MatchOrigin(origin, "*") {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE")
				w.Header().Set("Access-Control-Allow-Headers", "Content-Type, X-StorageApi-Token")
				w.WriteHeader(204)
				return
			}
			h.ServeHTTP(w, r)
			return
		}
		h.ServeHTTP(w, r)
		return
	})
}
