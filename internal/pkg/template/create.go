package template

import (
	"context"

	"github.com/keboola/keboola-as-code/internal/pkg/jsonnet"
	"github.com/keboola/keboola-as-code/internal/pkg/mapper/template/replacevalues"
	"github.com/keboola/keboola-as-code/internal/pkg/model"
)

// CreateContext represents the process of replacing values when creating a template from a remote project.
//
// Process description:
//   1. There is some remote project.
//      - It has unique objects IDs. For example ID "12345" for a config.
//   2. When creating a template, the user defines a human-readable ID for each object.
//      - For example "my-config-id" for "12345" config.
//      - See "dialog.AskCreateTemplateOpts".
//      - Not all project objects need to be copied to the template, see CreateContext.RemoteObjectsFilter.
//   3. Project is pulled to the template, see "pkg/lib/operation/template/sync/pull"
//      - Each ID is replaced by a function placeholder.
//        For example "12345" -> "<<~~func:ConfigId:["my-config-id"]~~>>".
//      - This is because we use Json as an intermediate step in generating a JsonNet template.
//      - In Json we can't define a function. Therefore, we use the string placeholder.
//      - IDs -> placeholders are replaced by "internal/pkg/mapper/template/replacevalues"
//    4. Template is saved to the filesystem.
//      - Json files are converted to JsonNet by "internal/pkg/mapper/template/jsonnetfiles"
//      - Placeholders are replaced by function calls.
//      - For example "foo <<~~func:ConfigId:["my-config-id"]~~>> bar" is replaced by "foo " + ConfigId("my-config-id") + " bar".
//      - Functions calls are generated by "jsonnet.FormatAst", and "jsonnet.ReplacePlaceholdersRecursive".
//
// CreateContext.RemoteObjectsFilter() defines which objects will be part of the template.
// CreateContext.Replacements() returns placeholders for ConfigId / ConfigRowId JsonNet functions.
type CreateContext struct {
	_context
	remoteFilter model.ObjectsFilter
	replacements *replacevalues.Values
}

type ConfigDef struct {
	Key        model.ConfigKey
	TemplateId string
	Rows       []ConfigRowDef
}

type ConfigRowDef struct {
	Key        model.ConfigRowKey
	TemplateId string
}

func NewCreateContext(ctx context.Context, sourceBranch model.BranchKey, configs []ConfigDef) *CreateContext {
	return &CreateContext{
		_context:     baseContext(ctx),
		remoteFilter: remoteFilterForCreate(sourceBranch, configs),
		replacements: replacementsForCreate(sourceBranch, configs),
	}
}

func (c *CreateContext) RemoteObjectsFilter() model.ObjectsFilter {
	return c.remoteFilter
}

func (c *CreateContext) LocalObjectsFilter() model.ObjectsFilter {
	return model.NoFilter()
}

func (c *CreateContext) JsonNetContext() *jsonnet.Context {
	// When saving a template, nothing needs to be set.
	return nil
}

func (c *CreateContext) Replacements() (*replacevalues.Values, error) {
	return c.replacements, nil
}

func replacementsForCreate(sourceBranch model.BranchKey, configs []ConfigDef) *replacevalues.Values {
	replacements := replacevalues.NewValues()

	// Replace BranchId, in template all objects have BranchId = 0
	replacements.AddKey(sourceBranch, model.BranchKey{Id: 0})

	// Configs
	for _, config := range configs {
		newConfigId := model.ConfigId(jsonnet.ConfigIdPlaceholder(config.TemplateId))
		newConfigKey := config.Key
		newConfigKey.BranchId = 0
		newConfigKey.Id = newConfigId
		replacements.AddKey(config.Key, newConfigKey)

		// Rows
		for _, row := range config.Rows {
			newRowId := model.RowId(jsonnet.ConfigRowIdPlaceholder(row.TemplateId))
			newRowKey := row.Key
			newRowKey.BranchId = 0
			newRowKey.ConfigId = newConfigId
			newRowKey.Id = newRowId
			replacements.AddKey(row.Key, newRowKey)
		}
	}

	return replacements
}

func remoteFilterForCreate(sourceBranch model.BranchKey, configs []ConfigDef) model.ObjectsFilter {
	var keys []model.Key

	// Branch
	keys = append(keys, sourceBranch)

	// Configs and rows
	for _, config := range configs {
		keys = append(keys, config.Key)
		for _, row := range config.Rows {
			keys = append(keys, row.Key)
		}
	}

	filter := model.NoFilter()
	filter.SetAllowedKeys(keys)
	return filter
}
